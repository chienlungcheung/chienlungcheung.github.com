<!doctype html><html lang=zh-CN><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>使用 eBPF 调试生产环境的 Go 程序 - 二手知识</title>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-3CREWXCLR7"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-3CREWXCLR7")</script><meta name=Description content><meta property="og:title" content="使用 eBPF 调试生产环境的 Go 程序"><meta property="og:description" content="[toc]
最新的 Go Weekly 推送了这篇文章, eBPF 作为新时代的剖析工具正在如火如荼发展, 读完感觉用来入门很好, 就根据自己理解编译了这篇文章. 做实验过程遇到一些问题, 在最后加了一个番外章节可参考.
下面正式开始."><meta property="og:type" content="article"><meta property="og:url" content="https://chienlungcheung.github.io/%E4%BD%BF%E7%94%A8-ebpf-%E8%B0%83%E8%AF%95%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E7%9A%84-go-%E7%A8%8B%E5%BA%8F/"><meta property="og:image" content="https://chienlungcheung.github.io/logo.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-09-21T22:43:27+08:00"><meta property="article:modified_time" content="2020-09-21T22:43:27+08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://chienlungcheung.github.io/logo.png"><meta name=twitter:title content="使用 eBPF 调试生产环境的 Go 程序"><meta name=twitter:description content="[toc]
最新的 Go Weekly 推送了这篇文章, eBPF 作为新时代的剖析工具正在如火如荼发展, 读完感觉用来入门很好, 就根据自己理解编译了这篇文章. 做实验过程遇到一些问题, 在最后加了一个番外章节可参考.
下面正式开始."><meta name=twitter:site content="@haricheung"><meta name=application-name content="DoIt"><meta name=apple-mobile-web-app-title content="DoIt"><meta name=theme-color content="#f8f8f8"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=canonical href=https://chienlungcheung.github.io/%E4%BD%BF%E7%94%A8-ebpf-%E8%B0%83%E8%AF%95%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E7%9A%84-go-%E7%A8%8B%E5%BA%8F/><link rel=prev href=https://chienlungcheung.github.io/leveldb-annotations-1-interfaces-and-files/><link rel=next href=https://chienlungcheung.github.io/leveldb-annotations-2-log-read-write/><link rel=stylesheet href=/lib/normalize/normalize.min.css><link rel=stylesheet href=/css/color.css><link rel=stylesheet href=/css/style.min.css><link rel=preload as=style onload='this.onload=null,this.rel="stylesheet"' href=/lib/fontawesome-free/all.min.css><noscript><link rel=stylesheet href=/lib/fontawesome-free/all.min.css></noscript><link rel=preload as=style onload='this.onload=null,this.rel="stylesheet"' href=/lib/animate/animate.min.css><noscript><link rel=stylesheet href=/lib/animate/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"使用 eBPF 调试生产环境的 Go 程序","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/chienlungcheung.github.io\/%E4%BD%BF%E7%94%A8-ebpf-%E8%B0%83%E8%AF%95%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E7%9A%84-go-%E7%A8%8B%E5%BA%8F\/"},"genre":"posts","keywords":"eBPF, golang","wordcount":2976,"url":"https:\/\/chienlungcheung.github.io\/%E4%BD%BF%E7%94%A8-ebpf-%E8%B0%83%E8%AF%95%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E7%9A%84-go-%E7%A8%8B%E5%BA%8F\/","datePublished":"2020-09-21T22:43:27+08:00","dateModified":"2020-09-21T22:43:27+08:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"Hari"},"description":""}</script><script src=//instant.page/5.1.1 defer type=module integrity=sha384-MWfCL6g1OTGsbSwfuMHc8+8J2u71/LA8dzlIN3ycajckxuZZmF+DNjdm7O6H3PSq></script></head><body header-desktop=fixed header-mobile=auto><script type=text/javascript>function setTheme(e){document.body.setAttribute("theme",e),document.documentElement.style.setProperty("color-scheme",e==="light"?"light":"dark"),window.theme=e}function saveTheme(e){window.localStorage&&localStorage.setItem("theme",e)}function getMeta(e){const t=document.getElementsByTagName("meta");for(let n=0;n<t.length;n++)if(t[n].getAttribute("name")===e)return t[n];return""}if(window.localStorage&&localStorage.getItem("theme")){let e=localStorage.getItem("theme");e==="light"||e==="dark"||e==="black"?setTheme(e):setTheme(window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light")}else"auto"==="light"||"auto"==="dark"||"auto"==="black"?(setTheme("auto"),saveTheme("auto")):(saveTheme("auto"),setTheme(window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light"));let metaColors={light:"#f8f8f8",dark:"#252627",black:"#000000"};getMeta("theme-color").content=metaColors[document.body.getAttribute("theme")]</script><div id=back-to-top></div><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title=二手知识>二手知识</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>文章 </a><a class=menu-item href=/tags/>标签 </a><a class=menu-item href=/categories/>分类 </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop>
<input type=text placeholder=搜索文章标题或内容... id=search-input-desktop>
<a href=# class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fas fa-search fa-fw"></i>
</a><a href=# class="search-button search-clear" id=search-clear-desktop title=清空><i class="fas fa-times-circle fa-fw"></i>
</a><span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin"></i>
</span></span><a href=# class="menu-item theme-select" title=切换主题><i class="fas fa-adjust fa-fw"></i>
<select class=color-theme-select id=theme-select-desktop title=切换主题><option value=light>浅色</option><option value=dark>深色</option><option value=black>黑色</option><option value=auto>跟随系统</option></select></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title=二手知识>二手知识</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容... id=search-input-mobile>
<a href=# class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fas fa-search fa-fw"></i>
</a><a href=# class="search-button search-clear" id=search-clear-mobile title=清空><i class="fas fa-times-circle fa-fw"></i>
</a><span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin"></i></span></div><a href=# class=search-cancel id=search-cancel-mobile>取消</a></div><a class=menu-item href=/posts/ title>文章</a><a class=menu-item href=/tags/ title>标签</a><a class=menu-item href=/categories/ title>分类</a><a href=# class="menu-item theme-select" title=切换主题>
<i class="fas fa-adjust fa-fw"></i>
<select class=color-theme-select id=theme-select-mobile title=切换主题><option value=light>浅色</option><option value=dark>深色</option><option value=black>黑色</option><option value=auto>跟随系统</option></select></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>目录</h2><div class=toc-content id=toc-content-auto><nav id=TableOfContents><ul><li><a href=#介绍>介绍</a></li><li><a href=#什么是-ebpf>什么是 eBPF</a></li><li><a href=#uprobes>Uprobes</a></li><li><a href=#构建追踪程序>构建追踪程序</a></li><li><a href=#番外>番外</a><ul><li><a href=#安装-bcc>安装 BCC</a></li><li><a href=#too-many-arguments-编译错误>too many arguments 编译错误</a></li></ul></li></ul></nav></div></div><script>document.getElementsByTagName("main")[0].setAttribute("autoTOC","true")</script><article class="page single"><h1 class="single-title animate__animated animate__flipInX">使用 eBPF 调试生产环境的 Go 程序</h1><div class=post-meta><div class=post-meta-line><span class=post-author><i class="author fas fa-user-circle fa-fw"></i><a href=/ title=Author rel=author class=author>Hari</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2020-09-21>2020-09-21</time>&nbsp;<i class="far fa-edit fa-fw"></i>&nbsp;<time datetime=2020-09-21>2020-09-21</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 2976 字&nbsp;
<i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 6 分钟&nbsp;</div></div><div class="details toc" id=toc-static kept><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fas fa-angle-right"></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#介绍>介绍</a></li><li><a href=#什么是-ebpf>什么是 eBPF</a></li><li><a href=#uprobes>Uprobes</a></li><li><a href=#构建追踪程序>构建追踪程序</a></li><li><a href=#番外>番外</a><ul><li><a href=#安装-bcc>安装 BCC</a></li><li><a href=#too-many-arguments-编译错误>too many arguments 编译错误</a></li></ul></li></ul></nav></div></div><div class=content id=content><p>[toc]</p><p>最新的 Go Weekly 推送了<a href=https://blog.pixielabs.ai/blog/ebpf-function-tracing/post/ target=_blank rel="noopener noreferrer">这篇文章</a>, eBPF 作为新时代的剖析工具正在如火如荼发展, 读完感觉用来入门很好, 就根据自己理解编译了这篇文章. 做实验过程遇到一些问题, 在最后加了一个番外章节可参考.</p><p>下面正式开始.</p><p>不用重新编译/部署线上程序而是借助 eBPF 即可实现对程序进行调试, 接下来我们会用一个系列文章介绍我们是怎么做的, 这是开篇. 本篇描述了如何使用 <a href=https://github.com/iovisor/gobpf target=_blank rel="noopener noreferrer">gobpf</a> 和 uprobe 来构建一个跟踪 Go 程序函数入口参数变化的应用. 这里介绍的技术可以扩展到其它编译型语言, 如 C++, Rust 等等. 本系列文章后续将会讨论如何使用 eBPF 来跟踪 HTTP/gRPC 数据和 SSL 等等.</p><h2 id=介绍 class=headerLink><a href=#%e4%bb%8b%e7%bb%8d class=header-mark></a>介绍</h2><p>当调试程序时, 我们一般对捕获程序的运行时状态非常感兴趣. 因为这可以让我们检查程序在干什么, 并能让我们确定 bug 出现在程序的哪一块. 观察运行时状态的一个简单方式是使用调试器. 比如针对 Go 程序, 我们可以使用 Delve 和 gdb.</p><p>Delve 和 gdb 在开发环境中做调试表现没得说, 但是我们一般不会在线上使用此类工具. 它们的长处同时也是它们的短处, 因为调试器会导致线上程序中断, 甚至如果在调试过程中不小心改错某个变量的值而导致线上程序出现异常.</p><p>为了让线上调试过程的侵入和影响更小, 我们将会探索使用增强版的 BPF(<a href=https://ebpf.io/ target=_blank rel="noopener noreferrer">eBPF</a>, Linux 4.x+ 内核可用)和更高级的 Go 库 <a href=https://github.com/iovisor/gobpf target=_blank rel="noopener noreferrer">gobpf</a> 来达成目标.</p><h2 id=什么是-ebpf class=headerLink><a href=#%e4%bb%80%e4%b9%88%e6%98%af-ebpf class=header-mark></a>什么是 eBPF</h2><p>扩展型 BPF(eBPF) 是一项在 Linux 4.x+ 内核可用的技术. 你可以把它看作一个轻量级的沙箱 VM, 它运行在 Linux 内核中并且提供了针对内核内存的可信访问.</p><p>就像下面要说的, eBPF 允许内核运行 BPF 字节码. 虽然可用的前端(这里指的是编译器前端)语言多样, 但通常都是 C 语言的真子集. 通常 C 代码先通过 Clang 被编译为 BPF 字节码, 然后字节被验证以确保可以安全执行. 这些严格的验证保证了机器码不会有意或无意地危及 Linux 内核, 同时也确保了 BPF 探针在每次被触发时将会执行有限数目的指令. 这些保证确保了 eBPF 可以被用于性能敏感的应用中, 比如包过滤, 网络监控等等.</p><p>从功能上说, eBPF 允许你针对某些事件(如定时器事件, 网络事件或是函数调用事件)运行受限的 C 代码. 当因为一个函数调用事件被触发时, 我们把这些 eBPF 代码叫做探针. 这些探针既可以针对内核函数调用事件被触发(这时叫 kprobe, k 即 kernelspace), 也可以针对用户空间的函数调用事件被触发(这时叫 uprobe, u 即 userspace). 本篇文章讲解如何通过 uprobe 实现函数参数的动态追踪.</p><h2 id=uprobes class=headerLink><a href=#uprobes class=header-mark></a>Uprobes</h2><p>Uprobes 允许我们通过插入一个 debug trap 指令(在 x86 上就是 <code>int3</code>)触发一个软中断从而实现对运行在用户空间的程序进行拦截. 这也是调试器的工作原理. uprobe 运行过程本质上与其它 BPF 程序一样, 可以总结为下面图示:<figure><a class=lightgallery href=http://www.brendangregg.com/eBPF/linux_ebpf_internals.png title="BPF for tracing(from Brendan Gregg)" data-thumbnail=http://www.brendangregg.com/eBPF/linux_ebpf_internals.png><img loading=lazy src=http://www.brendangregg.com/eBPF/linux_ebpf_internals.png srcset="http://www.brendangregg.com/eBPF/linux_ebpf_internals.png, http://www.brendangregg.com/eBPF/linux_ebpf_internals.png 1.5x, http://www.brendangregg.com/eBPF/linux_ebpf_internals.png 2x" sizes=auto alt=http://www.brendangregg.com/eBPF/linux_ebpf_internals.png></a></figure></p><center style=font-size:14px;color:silver;text-decoration:underline>用于跟踪的 BPF(来自 Brendan Gregg)</center><p>编译和验证过的 BPF 程序作为 uprobe 的一部分被执行, 同时执行结果写入到一个 buffer 中.</p><p>下面让我们研究下 uprobes 如何起作用的. 为了演示部署 uprobes 并捕获函数参数, 我们会用到<a href=https://github.com/pixie-labs/pixie/blob/main/demos/simple-gotracing/app.go target=_blank rel="noopener noreferrer">这个</a>简单的 demo 应用. 该 demo 相关部分下面介绍.</p><p><code>main()</code> 方法是一个简单的 HTTP server, 它暴露了一个监听 <em>/e</em> 端点的 <em>GET</em> 接口, 该接口通过迭代逼近计算自然常数 <code>e</code>(也叫欧拉数). <code>computeE</code> 方法有一个参数 <em>iters</em>, 它指定了逼近时的迭代次数. 迭代次数越多, 结果越精确, 当然耗费 CPU 也越多. 迭代逼近算法不是我们本次关注重点, 感兴趣的可以自己研究下. 我们仅对追踪调用 <code>computeE</code> 方法时的参数感兴趣.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>computeE</span><span class=p>(</span><span class=nx>iterations</span> <span class=kt>int64</span><span class=p>)</span> <span class=kt>float64</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>res</span> <span class=o>:=</span> <span class=mf>2.0</span>
</span></span><span class=line><span class=cl>  <span class=nx>fact</span> <span class=o>:=</span> <span class=mf>1.0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=nb>int64</span><span class=p>(</span><span class=mi>2</span><span class=p>);</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>iterations</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>fact</span> <span class=o>*=</span> <span class=nb>float64</span><span class=p>(</span><span class=nx>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>res</span> <span class=o>+=</span> <span class=mi>1</span> <span class=o>/</span> <span class=nx>fact</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>res</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>http</span><span class=p>.</span><span class=nf>HandleFunc</span><span class=p>(</span><span class=s>&#34;/e&#34;</span><span class=p>,</span> <span class=kd>func</span><span class=p>(</span><span class=nx>w</span> <span class=nx>http</span><span class=p>.</span><span class=nx>ResponseWriter</span><span class=p>,</span> <span class=nx>r</span> <span class=o>*</span><span class=nx>http</span><span class=p>.</span><span class=nx>Request</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ... 省略代码用于从 get 请求中解析 iters 参数, 若为空则使用默认值
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>w</span><span class=p>.</span><span class=nf>Write</span><span class=p>([]</span><span class=nb>byte</span><span class=p>(</span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Sprintf</span><span class=p>(</span><span class=s>&#34;e = %0.4f\n&#34;</span><span class=p>,</span> <span class=nf>computeE</span><span class=p>(</span><span class=nx>iters</span><span class=p>))))</span>
</span></span><span class=line><span class=cl>  <span class=p>})</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 启动 server...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>为了进行后面的实验以及为最后采用 gdb 验证修改生效, 我们采用如下指令编译该代码:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ go build  -gcflags <span class=s2>&#34;-N -l&#34;</span> app.go
</span></span></code></pre></td></tr></table></div></div><p>为了理解 uprobe 如何工作的, 我们看看可执行文件中要追踪的符号. 既然 uprobes 通过插入一个 debug trap 指令到可执行文件来实现, 我们先要确定要追踪的函数地址是什么. Go 程序在 Linux 上的二进制采用 ELF 格式存储 debug 信息, 该信息甚至在优化过的二进制中也是存在的, 除非 debug 数据被裁剪掉了. 我们可以使用命令 <code>objdump</code> 来检查二进制文件中的符号:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1>## 执行下面命令之前需要你先将上面 go 程序编译为名为 app 的二进制文件.</span>
</span></span><span class=line><span class=cl><span class=c1>## objdump --syms 可以从可执行程序中导出全部符号, 然后通过 grep 查找 computeE.</span>
</span></span><span class=line><span class=cl><span class=c1>## 具体输出可能与你机器上不同, 这没什么问题.</span>
</span></span><span class=line><span class=cl>$ objdump --syms app <span class=p>|</span> grep computeE
</span></span><span class=line><span class=cl>00000000000x6600e0 g     F .text  000000000000004b             main.computeE
</span></span></code></pre></td></tr></table></div></div><p>从上述输出可以看到, <code>computeE</code> 方法的入口地址为 <code>0x0x6600e0</code>. 为了看一下这个地址附近的指令, 我们可以通过 <code>objdump</code> 来反汇编该二进制文件(通过命令行选项 <code>-d</code>). 反汇编代码如下:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ objdump -d app <span class=p>|</span> grep -A <span class=m>1</span> 0x6600e0
</span></span><span class=line><span class=cl>00000000000x6600e0 &lt;main.computeE&gt;:
</span></span><span class=line><span class=cl>  0x6600e0:       <span class=m>48</span> 8b <span class=m>44</span> <span class=m>24</span> <span class=m>08</span>          mov    0x8<span class=o>(</span>%rsp<span class=o>)</span>,%rax
</span></span></code></pre></td></tr></table></div></div><p>从上面汇编代码可以看到当 <code>computeE</code> 方法被调用时会执行哪些指令. 第一条指令是 <code>mov 0x8(%rsp),%rax</code>, 该指令将距寄存器 <code>rsp</code> 保存的地址(栈指针寄存器保存的是 <code>computeE</code> 方法的入口地址)相对偏移量为 <code>0x8</code> 处的内容移动到寄存器 <code>rax</code> 中. 这个被移动的值即为 <code>computeE</code> 方法的入参 <code>iterations</code> 的值. Go 程序的参数通过栈来传递.</p><p>好了, 记住上面提到的信息, 我们来看看如何实现针对 <code>computeE</code> 方法的参数追踪.</p><h2 id=构建追踪程序 class=headerLink><a href=#%e6%9e%84%e5%bb%ba%e8%bf%bd%e8%b8%aa%e7%a8%8b%e5%ba%8f class=header-mark></a>构建追踪程序</h2><p>我们给这个追踪程序起个名叫 Tracer. 为了捕获前面提到的事件, 我们需要注册一个 uprobe 函数, 并且还得有个用户态函数负责去读 uprobe 的输出, 具体如下图所示:</p><p><figure><a class=lightgallery href=https://blog.pixielabs.ai/static/9f8b26f88f9b132440ef1b9d48b5a341/app-tracer.svg title="High-level overview showing the Tracer binary listening to perf events generated from the App" data-thumbnail=https://blog.pixielabs.ai/static/9f8b26f88f9b132440ef1b9d48b5a341/app-tracer.svg><img loading=lazy src=https://blog.pixielabs.ai/static/9f8b26f88f9b132440ef1b9d48b5a341/app-tracer.svg srcset="https://blog.pixielabs.ai/static/9f8b26f88f9b132440ef1b9d48b5a341/app-tracer.svg, https://blog.pixielabs.ai/static/9f8b26f88f9b132440ef1b9d48b5a341/app-tracer.svg 1.5x, https://blog.pixielabs.ai/static/9f8b26f88f9b132440ef1b9d48b5a341/app-tracer.svg 2x" sizes=auto alt=https://blog.pixielabs.ai/static/9f8b26f88f9b132440ef1b9d48b5a341/app-tracer.svg></a></figure></p><p>我们编写一个叫做 <code>tracer</code> 的应用, 由它负责注册 BPF 代码, 同时读取这些 BPF 代码的输出. 如上图所示, uprobe 将会简单地输出到一个 <code>perf-buffer</code> 中, 该结构体是用于 perf 事件的 linux 内核数据结构.</p><p>万事俱备, 我们来看看当我们增加一个 uprobe 时会发生哪些事情. 下面的图显示了 Linux 内核如何使用一个 uprobe 来修改一个已有的二进制程序. 前文提到的软中断 <code>int3</code> 作为第一条指令被插入到 <code>main.computeE</code> 方法中. 这条指令将会在执行时触发一个软中断, 从而允许 Linux 内核来执行 BPF 代码. 然后我们把 <code>computeE</code> 每次被调用时的参数输出到 perf-buffer 中, 这些值会被我们编写的 <code>tracer</code> 应用异步地读取.</p><p><figure><a class=lightgallery href=https://blog.pixielabs.ai/static/87301c7282e8f8270fee2afb9fe85c81/app-trace.svg title="Details of how a debug trap instruction is used call a BPF program" data-thumbnail=https://blog.pixielabs.ai/static/87301c7282e8f8270fee2afb9fe85c81/app-trace.svg><img loading=lazy src=https://blog.pixielabs.ai/static/87301c7282e8f8270fee2afb9fe85c81/app-trace.svg srcset="https://blog.pixielabs.ai/static/87301c7282e8f8270fee2afb9fe85c81/app-trace.svg, https://blog.pixielabs.ai/static/87301c7282e8f8270fee2afb9fe85c81/app-trace.svg 1.5x, https://blog.pixielabs.ai/static/87301c7282e8f8270fee2afb9fe85c81/app-trace.svg 2x" sizes=auto alt=https://blog.pixielabs.ai/static/87301c7282e8f8270fee2afb9fe85c81/app-trace.svg></a></figure></p><p>就我们这个需求来说, 相应的 BPF 代码很简单, C 代码如下:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;uapi/linux/ptrace.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=nf>BPF_PERF_OUTPUT</span><span class=p>(</span><span class=n>trace</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// 该函数将会被注册, 以便每次 main.computeE 被调用时该函数也会被调用
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>inline</span> <span class=kt>int</span> <span class=nf>computeECalled</span><span class=p>(</span><span class=k>struct</span> <span class=n>pt_regs</span> <span class=o>*</span><span class=n>ctx</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// main.computeE 的入参保存在了 ax 寄存器里.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>long</span> <span class=n>val</span> <span class=o>=</span> <span class=n>ctx</span><span class=o>-&gt;</span><span class=n>ax</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>trace</span><span class=p>.</span><span class=nf>perf_submit</span><span class=p>(</span><span class=n>ctx</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>val</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>val</span><span class=p>));</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>我们注册上面代码以便 <code>main.computeE</code> 方法被调用它们也会被执行. 这些代码被执行时, 我们仅仅读取函数参数然后写到 perf-buffer 中. 实现这个功能需要很多样板代码, 为了方便示意这里都省掉了, 完整的例子见<a href=https://github.com/pixie-labs/pixie/blob/main/demos/simple-gotracing/trace_example/trace.go target=_blank rel="noopener noreferrer">这里</a>.</p><p>好了, 我们现在有个针对 <code>main.computeE</code> 的功能齐全的端到端参数追踪器了! 执行结果见下面动图:<figure><a class=lightgallery href=https://blog.pixielabs.ai/static/4de8713a5b05e1f9132350f333572174/e2e-demo.gif title="End-to-End demo" data-thumbnail=https://blog.pixielabs.ai/static/4de8713a5b05e1f9132350f333572174/e2e-demo.gif><img loading=lazy src=https://blog.pixielabs.ai/static/4de8713a5b05e1f9132350f333572174/e2e-demo.gif srcset="https://blog.pixielabs.ai/static/4de8713a5b05e1f9132350f333572174/e2e-demo.gif, https://blog.pixielabs.ai/static/4de8713a5b05e1f9132350f333572174/e2e-demo.gif 1.5x, https://blog.pixielabs.ai/static/4de8713a5b05e1f9132350f333572174/e2e-demo.gif 2x" sizes=auto alt=https://blog.pixielabs.ai/static/4de8713a5b05e1f9132350f333572174/e2e-demo.gif></a></figure></p><p>上述动图执行步骤如下:</p><ul><li>1 在 localhost:9090 启动待追踪程序 <code>./app</code>, 此时我们可以用 curl 访问该应用了, 具体命令为 <code>curl http://localhost:9090/e?iters=10</code></li><li>2 启动 trace 应用, 注意指定参数 <code>sudo ./trace --binary ../app/app</code>, 参数是第一步中待追踪程序对应的二进制文件的路径.</li><li>3 不停的执行 curl 命令, 使其 iters 参数取值不同, 则会看到 trace 应用输出你指定的 iters 值.</li></ul><p>还有个有意思的事情, 我们真的可以通过 GDB 看到针对二进制文件的修改. 下面我们 dump 出 <code>0x0x6600e0</code> 处的指令, 在我们运行 <code>trace</code> 之前是这样的:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ gdb ./app
</span></span><span class=line><span class=cl><span class=o>(</span>gdb<span class=o>)</span> display /4i 0x6600e0
</span></span><span class=line><span class=cl>1: x/4i 0x6600e0
</span></span><span class=line><span class=cl>   0x6600e0 &lt;main.computeE&gt;:    sub    <span class=nv>$0</span>x20,%rsp
</span></span><span class=line><span class=cl>   0x6600e4 &lt;main.computeE+4&gt;:  mov    %rbp,0x18<span class=o>(</span>%rsp<span class=o>)</span>
</span></span><span class=line><span class=cl>   0x6600e9 &lt;main.computeE+9&gt;:  lea    0x18<span class=o>(</span>%rsp<span class=o>)</span>,%rbp
</span></span><span class=line><span class=cl>   0x6600ee &lt;main.computeE+14&gt;: xorps  %xmm0,%xmm0
</span></span></code></pre></td></tr></table></div></div><p>在我们运行 <code>trace</code> 之后, 再次查看:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ gdb ./app
</span></span><span class=line><span class=cl><span class=o>(</span>gdb<span class=o>)</span> display /4i 0x65fecf
</span></span><span class=line><span class=cl>2: x/4i 0x6600e0
</span></span><span class=line><span class=cl>   0x6600e0 &lt;main.computeE&gt;:    int3   
</span></span><span class=line><span class=cl>   0x6600e1 &lt;main.computeE+1&gt;:  sub    <span class=nv>$0</span>x20,%esp
</span></span><span class=line><span class=cl>   0x6600e4 &lt;main.computeE+4&gt;:  mov    %rbp,0x18<span class=o>(</span>%rsp<span class=o>)</span>
</span></span><span class=line><span class=cl>   0x6600e9 &lt;main.computeE+9&gt;:  lea    0x18<span class=o>(</span>%rsp<span class=o>)</span>,%rbp
</span></span></code></pre></td></tr></table></div></div><p>看到了吗? <code>0x6600e0</code> 插入了 <code>int3</code> 指令.</p><h2 id=番外 class=headerLink><a href=#%e7%95%aa%e5%a4%96 class=header-mark></a>番外</h2><p>下面说一下实验过程遇到的问题以及解决办法.</p><h3 id=安装-bcc class=headerLink><a href=#%e5%ae%89%e8%a3%85-bcc class=header-mark></a>安装 BCC</h3><p>编译前文提到的 <code>trace</code> 应用之前需要安装 bcc. 以 Ubuntu 16.04 为例(其它系统请参考<a href=https://github.com/iovisor/bcc/blob/master/INSTALL.md target=_blank rel="noopener noreferrer">这里</a>):</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 4052245BD4284CDD
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=s2>&#34;deb https://repo.iovisor.org/apt/</span><span class=k>$(</span>lsb_release -cs<span class=k>)</span><span class=s2> </span><span class=k>$(</span>lsb_release -cs<span class=k>)</span><span class=s2> main&#34;</span> <span class=p>|</span> sudo tee /etc/apt/sources.list.d/iovisor.list
</span></span><span class=line><span class=cl>sudo apt-get update
</span></span><span class=line><span class=cl>sudo apt-get install bcc-tools libbcc-examples linux-headers-<span class=k>$(</span>uname -r<span class=k>)</span>
</span></span></code></pre></td></tr></table></div></div><p>如果安装速度慢, 而且你设置了 http_proxy/https_proxy, 请编辑 <code>/etc/sudoers</code> 新增一行 <code>Defaults env_keep = "http_proxy https_proxy"</code>, 这样速度至少会有百倍提升.</p><h3 id=too-many-arguments-编译错误 class=headerLink><a href=#too-many-arguments-%e7%bc%96%e8%af%91%e9%94%99%e8%af%af class=header-mark></a>too many arguments 编译错误</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=err>##</span> <span class=nx>github</span><span class=p>.</span><span class=nx>com</span><span class=o>/</span><span class=nx>iovisor</span><span class=o>/</span><span class=nx>gobpf</span><span class=o>/</span><span class=nx>bcc</span>
</span></span><span class=line><span class=cl><span class=p>..</span><span class=o>/</span><span class=p>..</span><span class=o>/</span><span class=p>..</span><span class=o>/</span><span class=p>..</span><span class=o>/</span><span class=k>go</span><span class=o>/</span><span class=nx>pkg</span><span class=o>/</span><span class=nx>mod</span><span class=o>/</span><span class=nx>github</span><span class=p>.</span><span class=nx>com</span><span class=o>/</span><span class=nx>iovisor</span><span class=o>/</span><span class=nx>gobpf</span><span class=err>@</span><span class=nx>v0</span><span class=mf>.0.0</span><span class=o>-</span><span class=mi>20200614202714</span><span class=o>-</span><span class=nx>e6b321d32103</span><span class=o>/</span><span class=nx>bcc</span><span class=o>/</span><span class=nx>module</span><span class=p>.</span><span class=k>go</span><span class=p>:</span><span class=mi>98</span><span class=p>:</span><span class=mi>40</span><span class=p>:</span> <span class=nx>too</span> <span class=nx>many</span> <span class=nx>arguments</span> <span class=nx>in</span> <span class=nx>call</span> <span class=nx>to</span> <span class=nx>_Cfunc_bpf_module_create_c_from_string</span>
</span></span><span class=line><span class=cl>        <span class=nf>have</span> <span class=p>(</span><span class=o>*</span><span class=nx>_Ctype_char</span><span class=p>,</span> <span class=nx>number</span><span class=p>,</span> <span class=o>**</span><span class=nx>_Ctype_char</span><span class=p>,</span> <span class=nx>_Ctype_int</span><span class=p>,</span> <span class=nx>_Ctype__Bool</span><span class=p>,</span> <span class=kc>nil</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nf>want</span> <span class=p>(</span><span class=o>*</span><span class=nx>_Ctype_char</span><span class=p>,</span> <span class=nx>_Ctype_uint</span><span class=p>,</span> <span class=o>**</span><span class=nx>_Ctype_char</span><span class=p>,</span> <span class=nx>_Ctype_int</span><span class=p>,</span> <span class=nx>_Ctype__Bool</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>..</span><span class=o>/</span><span class=p>..</span><span class=o>/</span><span class=p>..</span><span class=o>/</span><span class=p>..</span><span class=o>/</span><span class=k>go</span><span class=o>/</span><span class=nx>pkg</span><span class=o>/</span><span class=nx>mod</span><span class=o>/</span><span class=nx>github</span><span class=p>.</span><span class=nx>com</span><span class=o>/</span><span class=nx>iovisor</span><span class=o>/</span><span class=nx>gobpf</span><span class=err>@</span><span class=nx>v0</span><span class=mf>.0.0</span><span class=o>-</span><span class=mi>20200614202714</span><span class=o>-</span><span class=nx>e6b321d32103</span><span class=o>/</span><span class=nx>bcc</span><span class=o>/</span><span class=nx>module</span><span class=p>.</span><span class=k>go</span><span class=p>:</span><span class=mi>230</span><span class=p>:</span><span class=mi>28</span><span class=p>:</span> <span class=nx>too</span> <span class=nx>many</span> <span class=nx>arguments</span> <span class=nx>in</span> <span class=nx>call</span> <span class=nx>to</span> <span class=nx>_C2func_bcc_func_load</span>
</span></span><span class=line><span class=cl>        <span class=nf>have</span> <span class=p>(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span><span class=p>,</span> <span class=nx>_Ctype_int</span><span class=p>,</span> <span class=o>*</span><span class=nx>_Ctype_char</span><span class=p>,</span> <span class=o>*</span><span class=nx>_Ctype_struct_bpf_insn</span><span class=p>,</span> <span class=nx>_Ctype_int</span><span class=p>,</span> <span class=o>*</span><span class=nx>_Ctype_char</span><span class=p>,</span> <span class=nx>_Ctype_uint</span><span class=p>,</span> <span class=nx>_Ctype_int</span><span class=p>,</span> <span class=o>*</span><span class=nx>_Ctype_char</span><span class=p>,</span> <span class=nx>_Ctype_uint</span><span class=p>,</span> <span class=kc>nil</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nf>want</span> <span class=p>(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span><span class=p>,</span> <span class=nx>_Ctype_int</span><span class=p>,</span> <span class=o>*</span><span class=nx>_Ctype_char</span><span class=p>,</span> <span class=o>*</span><span class=nx>_Ctype_struct_bpf_insn</span><span class=p>,</span> <span class=nx>_Ctype_int</span><span class=p>,</span> <span class=o>*</span><span class=nx>_Ctype_char</span><span class=p>,</span> <span class=nx>_Ctype_uint</span><span class=p>,</span> <span class=nx>_Ctype_int</span><span class=p>,</span> <span class=o>*</span><span class=nx>_Ctype_char</span><span class=p>,</span> <span class=nx>_Ctype_uint</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>原因为<a href=https://github.com/iovisor/gobpf/commit/3ecafd366e4b239946d03c17f5a4beb5aef4935e#diff-f11d8f44bec322f0ba3a2ee148c82966 target=_blank rel="noopener noreferrer">这一行</a>增加的特性 <em>Update bcc_func_load to libbcc 0.11 with hardware offload support</em>, 以及<a href=https://github.com/iovisor/gobpf/commit/cda73bdde3bf14fc898d07b8936073e1aa197708 target=_blank rel="noopener noreferrer">这一行</a>增加的特性 <em>bcc: update bpf_module_create_c_from_string for bcc 0.11.0 (fixes #202)</em>.</p><p>我没有深究具体是什么导致的(初步怀疑是系统版本), 如果你急着看结果, 可以根据上面报错地址知道到 <code>module.go</code> 文件, 把涉及的两个函数的最后一个 <code>nil</code> 参数去掉就可以顺利编译了.</p><p>&ndash;End&ndash;</p></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>更新于 2020-09-21</span></div><div class=post-info-license></div></div><div class=post-info-line><div class=post-info-md><span><a class=link-to-mardown href=/%E4%BD%BF%E7%94%A8-ebpf-%E8%B0%83%E8%AF%95%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E7%9A%84-go-%E7%A8%8B%E5%BA%8F/index.md target=_blank rel="noopener noreferrer">阅读原始文档</a></span></div><div class=post-info-share><span><a href=# title="分享到 Twitter" data-sharer=twitter data-url=https://chienlungcheung.github.io/%E4%BD%BF%E7%94%A8-ebpf-%E8%B0%83%E8%AF%95%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E7%9A%84-go-%E7%A8%8B%E5%BA%8F/ data-title="使用 eBPF 调试生产环境的 Go 程序" data-via=haricheung data-hashtags=eBPF,golang><i class="fab fa-twitter fa-fw"></i></a><a href=# title="分享到 Facebook" data-sharer=facebook data-url=https://chienlungcheung.github.io/%E4%BD%BF%E7%94%A8-ebpf-%E8%B0%83%E8%AF%95%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E7%9A%84-go-%E7%A8%8B%E5%BA%8F/ data-hashtag=eBPF><i class="fab fa-facebook-square fa-fw"></i></a><a href=# title="分享到 WhatsApp" data-sharer=whatsapp data-url=https://chienlungcheung.github.io/%E4%BD%BF%E7%94%A8-ebpf-%E8%B0%83%E8%AF%95%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E7%9A%84-go-%E7%A8%8B%E5%BA%8F/ data-title="使用 eBPF 调试生产环境的 Go 程序" data-web><i class="fab fa-whatsapp fa-fw"></i></a><a href=# title="分享到 Line" data-sharer=line data-url=https://chienlungcheung.github.io/%E4%BD%BF%E7%94%A8-ebpf-%E8%B0%83%E8%AF%95%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E7%9A%84-go-%E7%A8%8B%E5%BA%8F/ data-title="使用 eBPF 调试生产环境的 Go 程序"><i data-svg-src=/lib/simple-icons/icons/line.min.svg></i></a><a href=# title="分享到 微博" data-sharer=weibo data-url=https://chienlungcheung.github.io/%E4%BD%BF%E7%94%A8-ebpf-%E8%B0%83%E8%AF%95%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E7%9A%84-go-%E7%A8%8B%E5%BA%8F/ data-title="使用 eBPF 调试生产环境的 Go 程序"><i class="fab fa-weibo fa-fw"></i></a><a href=# title="分享到 Myspace" data-sharer=myspace data-url=https://chienlungcheung.github.io/%E4%BD%BF%E7%94%A8-ebpf-%E8%B0%83%E8%AF%95%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E7%9A%84-go-%E7%A8%8B%E5%BA%8F/ data-title="使用 eBPF 调试生产环境的 Go 程序" data-description><i data-svg-src=/lib/simple-icons/icons/myspace.min.svg></i></a><a href=# title="分享到 Blogger" data-sharer=blogger data-url=https://chienlungcheung.github.io/%E4%BD%BF%E7%94%A8-ebpf-%E8%B0%83%E8%AF%95%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E7%9A%84-go-%E7%A8%8B%E5%BA%8F/ data-title="使用 eBPF 调试生产环境的 Go 程序" data-description><i class="fab fa-blogger fa-fw"></i></a><a href=# title="分享到 Evernote" data-sharer=evernote data-url=https://chienlungcheung.github.io/%E4%BD%BF%E7%94%A8-ebpf-%E8%B0%83%E8%AF%95%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E7%9A%84-go-%E7%A8%8B%E5%BA%8F/ data-title="使用 eBPF 调试生产环境的 Go 程序"><i class="fab fa-evernote fa-fw"></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/ebpf/>eBPF</a>,&nbsp;<a href=/tags/golang/>golang</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/leveldb-annotations-1-interfaces-and-files/ class=prev rel=prev title="Leveldb 源码详解系列之一: 接口与文件"><i class="fas fa-angle-left fa-fw"></i>Leveldb 源码详解系列之一: 接口与文件</a>
<a href=/leveldb-annotations-2-log-read-write/ class=next rel=next title="Leveldb 源码详解系列之二: log 读写">Leveldb 源码详解系列之二: log 读写<i class="fas fa-angle-right fa-fw"></i></a></div></div><div id=comments><div id=disqus_thread class=comment></div><noscript>Please enable JavaScript to view the comments powered by <a href=https://disqus.com/?ref_noscript>Disqus</a>.</noscript></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line>由 <a href=https://gohugo.io/ target=_blank rel="noopener noreferrer" title="Hugo 0.120.1">Hugo</a> 强力驱动&nbsp;|&nbsp;主题 - <a href=https://github.com/HEIGE-PCloud/DoIt target=_blank rel="noopener noreferrer" title="DoIt 0.3.0"><i class="far fa-edit fa-fw"></i> DoIt</a></div><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2019 - 2023</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=/ target=_blank rel="noopener noreferrer">Hari</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div><div class=footer-line></div><div class=footer-line></div></div></footer></div><div id=fixed-buttons><a href=#back-to-top id=back-to-top-button class=fixed-button title=回到顶部><i class="fas fa-arrow-up fa-fw"></i>
</a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment fa-fw"></i></a></div><div class=assets><link rel=stylesheet href=/lib/katex/katex.min.css><link rel=preload as=style onload='this.onload=null,this.rel="stylesheet"' href=/lib/katex/copy-tex.min.css><noscript><link rel=stylesheet href=/lib/katex/copy-tex.min.css></noscript><script type=text/javascript>window.config={code:{copyTitle:"复制到剪贴板",maxShownLines:10},comment:{},math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},search:{distance:100,findAllMatches:!1,fuseIndexURL:"/index.json",highlightTag:"em",ignoreFieldNorm:!1,ignoreLocation:!1,isCaseSensitive:!1,location:0,maxResultLength:10,minMatchCharLength:2,noResultsFound:"没有找到结果",snippetLength:50,threshold:.3,type:"fuse",useExtendedSearch:!1},sharerjs:!0,table:{sort:!0}}</script><script type=text/javascript src=https://Chienlung.disqus.com/embed.js defer></script><script type=text/javascript src=/lib/tablesort/tablesort.min.js></script><script type=text/javascript src=/lib/clipboard/clipboard.min.js></script><script type=text/javascript src=/lib/sharer/sharer.min.js></script><script type=text/javascript src=/lib/katex/katex.min.js defer></script><script type=text/javascript src=/lib/katex/auto-render.min.js defer></script><script type=text/javascript src=/lib/katex/copy-tex.min.js defer></script><script type=text/javascript src=/lib/katex/mhchem.min.js defer></script><script type=text/javascript src=/js/katex.min.js defer></script><script type=text/javascript src=/js/theme.min.js defer></script></div></body></html>