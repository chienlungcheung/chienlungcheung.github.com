<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>所有文章 - 二手知识</title><link>https://chienlungcheung.github.io/posts/</link><description>所有文章 | 二手知识</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>chienlungcheung@gmail.com (Hari)</managingEditor><webMaster>chienlungcheung@gmail.com (Hari)</webMaster><lastBuildDate>Tue, 29 Jun 2021 22:35:43 +0000</lastBuildDate><atom:link href="https://chienlungcheung.github.io/posts/" rel="self" type="application/rss+xml"/><item><title>Leveldb 源码详解系列之六: 文件缓存设计与实现</title><link>https://chienlungcheung.github.io/leveldb-annotations-6-table-cache/</link><pubDate>Tue, 29 Jun 2021 22:35:43 +0000</pubDate><author><name>Hari</name></author><guid>https://chienlungcheung.github.io/leveldb-annotations-6-table-cache/</guid><description><![CDATA[<p>上一篇讲了 leveldb 中 <code>Table</code> 的设计和实现, 它是磁盘 sstable 文件的内存形式, 但是 <code>Table</code> 在实际中不会被用户直接用到, 而是借助 <code>TableCache</code>.</p>]]></description></item><item><title>Leveldb 源码详解系列之五: SSTable 设计与实现</title><link>https://chienlungcheung.github.io/leveldb-annotations-5-sstable/</link><pubDate>Sat, 29 May 2021 14:02:43 +0000</pubDate><author><name>Hari</name></author><guid>https://chienlungcheung.github.io/leveldb-annotations-5-sstable/</guid><description>&lt;p>leveldb, leveldb, 每个 level 保存的内容就是一组 sorted string table (简称 sstable) 文件.&lt;/p></description></item><item><title>MapReduce: 分布式计算系统设计与实现</title><link>https://chienlungcheung.github.io/mapreduce-design-and-implementation/</link><pubDate>Wed, 03 Mar 2021 19:42:52 +0000</pubDate><author><name>Hari</name></author><guid>https://chienlungcheung.github.io/mapreduce-design-and-implementation/</guid><description><![CDATA[<p>本文基于内部分享 &lt;&ldquo;抄&quot;能力养成系列 &ndash; MapReduce: 分布式计算系统设计与实现&gt; 整理.</p>
<p>2003 年开始 Google 陆续放出三套系统的设计(GFS/MapReduce/Bigtable), 在互联网届掀起云计算狂潮一直影响至今. MapReduce 作为老二出场, 因为它的实现依赖于之前分享的 GFS 作为存储. 该论文一出, 便直接催生了 Hadoop 另一个重量级同名框架 MapReduce 的诞生. 时光荏苒, 虽然后面又出现了 spark/flink, 但是 MapReduce 在批处理领域的地位至今牢固. 下面就让我们一起看看 MapReduce 的设计, 希望为各位后续系统研发提供灵感. (Salute to Jeff).</p>]]></description></item><item><title>Leveldb 源码详解系列之四: 迭代器设计与实现</title><link>https://chienlungcheung.github.io/leveldb-annotations-4-iterator/</link><pubDate>Fri, 05 Feb 2021 13:53:51 +0000</pubDate><author><name>Hari</name></author><guid>https://chienlungcheung.github.io/leveldb-annotations-4-iterator/</guid><description>&lt;p>迭代器的设计和实现是 leveldb 的精华之一. 前几篇文章都多少提到了迭代器的使用, 本篇让我们深入一下迭代器的设计实现, 也为接下来的几篇剖析打下基础.&lt;/p></description></item><item><title>GFS: 一个高可用可扩展的分布式文件系统</title><link>https://chienlungcheung.github.io/gfs-%E4%B8%80%E4%B8%AA%E9%AB%98%E5%8F%AF%E7%94%A8%E5%8F%AF%E6%89%A9%E5%B1%95%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</link><pubDate>Fri, 11 Dec 2020 21:44:47 +0000</pubDate><author><name>Hari</name></author><guid>https://chienlungcheung.github.io/gfs-%E4%B8%80%E4%B8%AA%E9%AB%98%E5%8F%AF%E7%94%A8%E5%8F%AF%E6%89%A9%E5%B1%95%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</guid><description><![CDATA[<p>本文基于内部分享 &lt;&ldquo;抄&quot;能力养成系列 &ndash; GFS 设计&gt; 整理.</p>
<p>2003 年开始 Google 陆续放出三套系统的设计(GFS/MapReduce/Bigtable), 在互联网届掀起云计算狂潮一直影响至今. 该论文一出, 便催生了 Hadoop 中的 HDFS 的诞生. GFS 作为发轫, 目前许多业界知名的分布式系统设计仍然有着它的影子. 下面就让我们一起看看 GFS 的设计, 希望为各位后续系统研发提供灵感。(Salute to Jeff).</p>]]></description></item><item><title>Gorilla: 一个快速, 可扩展的, 内存式时序数据库</title><link>https://chienlungcheung.github.io/gorilla-%E4%B8%80%E4%B8%AA%E5%BF%AB%E9%80%9F-%E5%8F%AF%E6%89%A9%E5%B1%95%E7%9A%84-%E5%86%85%E5%AD%98%E5%BC%8F%E6%97%B6%E5%BA%8F%E6%95%B0%E6%8D%AE%E5%BA%93/</link><pubDate>Sat, 05 Dec 2020 10:19:30 +0000</pubDate><author><name>Hari</name></author><guid>https://chienlungcheung.github.io/gorilla-%E4%B8%80%E4%B8%AA%E5%BF%AB%E9%80%9F-%E5%8F%AF%E6%89%A9%E5%B1%95%E7%9A%84-%E5%86%85%E5%AD%98%E5%BC%8F%E6%97%B6%E5%BA%8F%E6%95%B0%E6%8D%AE%E5%BA%93/</guid><description><![CDATA[<p>本文基于内部分享 &lt;&ldquo;抄&quot;能力养成系列 &ndash; Gorilla 的设计和实现&gt; 整理.</p>
<p>Gorilla 是 Facebook 于 2015 年开放的一个快速, 可扩展的, 内存式时序数据库. 它的一些设计理念影响了后来的 Prometheus. 本文就其设计和实现进行深入分析希望能为各位后续在系统研发中提供灵感.</p>]]></description></item><item><title>Leveldb 源码详解系列之三: MemTable 设计与实现</title><link>https://chienlungcheung.github.io/leveldb-annotations-3-memtable/</link><pubDate>Thu, 01 Oct 2020 21:47:36 +0000</pubDate><author><name>Hari</name></author><guid>https://chienlungcheung.github.io/leveldb-annotations-3-memtable/</guid><description>&lt;p>memtable 可以看作是 log 文件的内存形式, 但是格式不同. 每个 log 文件在内存有一个对应的 memtable, 它和正在压实的 memtable(所以可能同时有两个 memtable 存在) 以及磁盘上的各个 level 包含的文件构成了数据全集. memtable 的本质就是一个 SkipList.&lt;/p></description></item><item><title>Leveldb 源码详解系列之二: log 读写</title><link>https://chienlungcheung.github.io/leveldb-annotations-2-log-read-write/</link><pubDate>Tue, 22 Sep 2020 19:16:28 +0000</pubDate><author><name>Hari</name></author><guid>https://chienlungcheung.github.io/leveldb-annotations-2-log-read-write/</guid><description><![CDATA[<p>我们先简单回顾下 log 文件相关的基础知识点, 具体请见 <a href="/leveldb-annotations-1-interfaces-and-files/" rel="">Leveldb 源码详解系列之一: 接口与文件</a>.</p>
<p>log 文件(*.log)保存着数据库最近一系列更新操作, 它相当于 leveldb 的 WAL(<a href="https://en.wikipedia.org/wiki/Write-ahead_logging" target="_blank" rel="noopener noreffer">write-ahead logging</a>). 当前在用的 log 文件内容同时也会被记录到一个内存数据结构中(即 <code>memtable</code> ). 每个更新操作都被追加到当前的 log 文件和 <code>memtable</code> 中. 当 log 文件大小达到一个预定义的大小时(默认大约 4MB), 这个 log 文件对应的 <code>memtable</code> 就会被转换为一个 sorted string table 文件落盘然后一个新的 log 文件就会被创建以保存未来的更新操作.</p>]]></description></item><item><title>使用 eBPF 调试生产环境的 Go 程序</title><link>https://chienlungcheung.github.io/%E4%BD%BF%E7%94%A8-ebpf-%E8%B0%83%E8%AF%95%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E7%9A%84-go-%E7%A8%8B%E5%BA%8F/</link><pubDate>Mon, 21 Sep 2020 22:43:27 +0000</pubDate><author><name>Hari</name></author><guid>https://chienlungcheung.github.io/%E4%BD%BF%E7%94%A8-ebpf-%E8%B0%83%E8%AF%95%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E7%9A%84-go-%E7%A8%8B%E5%BA%8F/</guid><description><![CDATA[<p>[toc]</p>
<p>最新的 Go Weekly 推送了<a href="https://blog.pixielabs.ai/blog/ebpf-function-tracing/post/" target="_blank" rel="noopener noreffer">这篇文章</a>, eBPF 作为新时代的剖析工具正在如火如荼发展, 读完感觉用来入门很好, 就根据自己理解编译了这篇文章. 做实验过程遇到一些问题, 在最后加了一个番外章节可参考.</p>
<p>下面正式开始.</p>]]></description></item><item><title>Leveldb 源码详解系列之一: 接口与文件</title><link>https://chienlungcheung.github.io/leveldb-annotations-1-interfaces-and-files/</link><pubDate>Fri, 11 Sep 2020 23:13:08 +0000</pubDate><author><name>Hari</name></author><guid>https://chienlungcheung.github.io/leveldb-annotations-1-interfaces-and-files/</guid><description><![CDATA[<h2 id="从哪里着手分析-leveldb-实现" class="headerLink">
    <a href="#%e4%bb%8e%e5%93%aa%e9%87%8c%e7%9d%80%e6%89%8b%e5%88%86%e6%9e%90-leveldb-%e5%ae%9e%e7%8e%b0" class="header-mark"></a>从哪里着手分析 leveldb 实现</h2><p>在了解了其基本使用以后, 如果想理解 leveldb 基本原理, 则有两个抓手. 第一个是  <code>include</code> 目录下的头文件, 尤其是 <code>db.h</code> , 第二个就是它的文件类型及其格式.</p>
<p>下面我们就从接口和文件两个方向来切入 leveldb 的设计与实现.</p>]]></description></item></channel></rss>