<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>leveldb - 标签 - 二手知识</title><link>https://chienlungcheung.github.io/tags/leveldb/</link><description>leveldb - 标签 - 二手知识</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>chienlungcheung@gmail.com (Hari)</managingEditor><webMaster>chienlungcheung@gmail.com (Hari)</webMaster><lastBuildDate>Tue, 29 Jun 2021 22:35:43 +0000</lastBuildDate><atom:link href="https://chienlungcheung.github.io/tags/leveldb/" rel="self" type="application/rss+xml"/><item><title>Leveldb 源码详解系列之六: 文件缓存设计与实现</title><link>https://chienlungcheung.github.io/leveldb-annotations-6-table-cache/</link><pubDate>Tue, 29 Jun 2021 22:35:43 +0000</pubDate><author><name>Hari</name></author><guid>https://chienlungcheung.github.io/leveldb-annotations-6-table-cache/</guid><description><![CDATA[<p>上一篇讲了 leveldb 中 <code>Table</code> 的设计和实现, 它是磁盘 sstable 文件的内存形式, 但是 <code>Table</code> 在实际中不会被用户直接用到, 而是借助 <code>TableCache</code>.</p>]]></description></item><item><title>Leveldb 源码详解系列之五: SSTable 设计与实现</title><link>https://chienlungcheung.github.io/leveldb-annotations-5-sstable/</link><pubDate>Sat, 29 May 2021 14:02:43 +0000</pubDate><author><name>Hari</name></author><guid>https://chienlungcheung.github.io/leveldb-annotations-5-sstable/</guid><description>&lt;p>leveldb, leveldb, 每个 level 保存的内容就是一组 sorted string table (简称 sstable) 文件.&lt;/p></description></item><item><title>MapReduce: 分布式计算系统设计与实现</title><link>https://chienlungcheung.github.io/mapreduce-design-and-implementation/</link><pubDate>Wed, 03 Mar 2021 19:42:52 +0000</pubDate><author><name>Hari</name></author><guid>https://chienlungcheung.github.io/mapreduce-design-and-implementation/</guid><description><![CDATA[<p>本文基于内部分享 &lt;&ldquo;抄&quot;能力养成系列 &ndash; MapReduce: 分布式计算系统设计与实现&gt; 整理.</p>
<p>2003 年开始 Google 陆续放出三套系统的设计(GFS/MapReduce/Bigtable), 在互联网届掀起云计算狂潮一直影响至今. MapReduce 作为老二出场, 因为它的实现依赖于之前分享的 GFS 作为存储. 该论文一出, 便直接催生了 Hadoop 另一个重量级同名框架 MapReduce 的诞生. 时光荏苒, 虽然后面又出现了 spark/flink, 但是 MapReduce 在批处理领域的地位至今牢固. 下面就让我们一起看看 MapReduce 的设计, 希望为各位后续系统研发提供灵感. (Salute to Jeff).</p>]]></description></item><item><title>Leveldb 源码详解系列之四: 迭代器设计与实现</title><link>https://chienlungcheung.github.io/leveldb-annotations-4-iterator/</link><pubDate>Fri, 05 Feb 2021 13:53:51 +0000</pubDate><author><name>Hari</name></author><guid>https://chienlungcheung.github.io/leveldb-annotations-4-iterator/</guid><description>&lt;p>迭代器的设计和实现是 leveldb 的精华之一. 前几篇文章都多少提到了迭代器的使用, 本篇让我们深入一下迭代器的设计实现, 也为接下来的几篇剖析打下基础.&lt;/p></description></item><item><title>Leveldb 源码详解系列之三: MemTable 设计与实现</title><link>https://chienlungcheung.github.io/leveldb-annotations-3-memtable/</link><pubDate>Thu, 01 Oct 2020 21:47:36 +0000</pubDate><author><name>Hari</name></author><guid>https://chienlungcheung.github.io/leveldb-annotations-3-memtable/</guid><description>&lt;p>memtable 可以看作是 log 文件的内存形式, 但是格式不同. 每个 log 文件在内存有一个对应的 memtable, 它和正在压实的 memtable(所以可能同时有两个 memtable 存在) 以及磁盘上的各个 level 包含的文件构成了数据全集. memtable 的本质就是一个 SkipList.&lt;/p></description></item><item><title>Leveldb 源码详解系列之二: log 读写</title><link>https://chienlungcheung.github.io/leveldb-annotations-2-log-read-write/</link><pubDate>Tue, 22 Sep 2020 19:16:28 +0000</pubDate><author><name>Hari</name></author><guid>https://chienlungcheung.github.io/leveldb-annotations-2-log-read-write/</guid><description><![CDATA[<p>我们先简单回顾下 log 文件相关的基础知识点, 具体请见 <a href="/leveldb-annotations-1-interfaces-and-files/" rel="">Leveldb 源码详解系列之一: 接口与文件</a>.</p>
<p>log 文件(*.log)保存着数据库最近一系列更新操作, 它相当于 leveldb 的 WAL(<a href="https://en.wikipedia.org/wiki/Write-ahead_logging" target="_blank" rel="noopener noreffer">write-ahead logging</a>). 当前在用的 log 文件内容同时也会被记录到一个内存数据结构中(即 <code>memtable</code> ). 每个更新操作都被追加到当前的 log 文件和 <code>memtable</code> 中. 当 log 文件大小达到一个预定义的大小时(默认大约 4MB), 这个 log 文件对应的 <code>memtable</code> 就会被转换为一个 sorted string table 文件落盘然后一个新的 log 文件就会被创建以保存未来的更新操作.</p>]]></description></item><item><title>Leveldb 源码详解系列之一: 接口与文件</title><link>https://chienlungcheung.github.io/leveldb-annotations-1-interfaces-and-files/</link><pubDate>Fri, 11 Sep 2020 23:13:08 +0000</pubDate><author><name>Hari</name></author><guid>https://chienlungcheung.github.io/leveldb-annotations-1-interfaces-and-files/</guid><description><![CDATA[<h2 id="从哪里着手分析-leveldb-实现" class="headerLink">
    <a href="#%e4%bb%8e%e5%93%aa%e9%87%8c%e7%9d%80%e6%89%8b%e5%88%86%e6%9e%90-leveldb-%e5%ae%9e%e7%8e%b0" class="header-mark"></a>从哪里着手分析 leveldb 实现</h2><p>在了解了其基本使用以后, 如果想理解 leveldb 基本原理, 则有两个抓手. 第一个是  <code>include</code> 目录下的头文件, 尤其是 <code>db.h</code> , 第二个就是它的文件类型及其格式.</p>
<p>下面我们就从接口和文件两个方向来切入 leveldb 的设计与实现.</p>]]></description></item><item><title>Leveldb 源码详解系列之零: 基本介绍与使用举例</title><link>https://chienlungcheung.github.io/leveldb-annotations-0-usage-and-examples/</link><pubDate>Fri, 11 Sep 2020 21:13:08 +0000</pubDate><author><name>Hari</name></author><guid>https://chienlungcheung.github.io/leveldb-annotations-0-usage-and-examples/</guid><description><![CDATA[<p><strong>Leveldb</strong> 是一个高速 KV 数据库, 它提供了一个持久性的 KV 存储. 其中 keys 和 values 都是随机字节数组, 并且存储时根据用户指定的比较函数对 keys 进行排序.</p>
<p>它由 Google 开发的, 其作者为大名鼎鼎的 Sanjay Ghemawat (<a href="mailto:sanjay@google.com" rel="">sanjay@google.com</a>) 和 Jeff Dean (<a href="mailto:jeff@google.com" rel="">jeff@google.com</a>). 感谢他们对人类的贡献.</p>]]></description></item></channel></rss>