<!doctype html><html lang=zh-CN><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>Leveldb 源码详解系列之五: SSTable 设计与实现 - 二手知识</title>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-3CREWXCLR7"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-3CREWXCLR7")</script><meta name=Description content><meta property="og:title" content="Leveldb 源码详解系列之五: SSTable 设计与实现"><meta property="og:description" content="leveldb, leveldb, 每个 level 保存的内容就是一组 sorted string table (简称 sstable) 文件."><meta property="og:type" content="article"><meta property="og:url" content="https://chienlungcheung.github.io/leveldb-annotations-5-sstable/"><meta property="og:image" content="https://chienlungcheung.github.io/logo.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-05-29T14:02:43+08:00"><meta property="article:modified_time" content="2021-05-29T14:02:43+08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://chienlungcheung.github.io/logo.png"><meta name=twitter:title content="Leveldb 源码详解系列之五: SSTable 设计与实现"><meta name=twitter:description content="leveldb, leveldb, 每个 level 保存的内容就是一组 sorted string table (简称 sstable) 文件."><meta name=twitter:site content="@haricheung"><meta name=application-name content="DoIt"><meta name=apple-mobile-web-app-title content="DoIt"><meta name=theme-color content="#f8f8f8"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=canonical href=https://chienlungcheung.github.io/leveldb-annotations-5-sstable/><link rel=prev href=https://chienlungcheung.github.io/mapreduce-design-and-implementation/><link rel=next href=https://chienlungcheung.github.io/leveldb-annotations-6-table-cache/><link rel=stylesheet href=/lib/normalize/normalize.min.css><link rel=stylesheet href=/css/color.css><link rel=stylesheet href=/css/style.min.css><link rel=preload as=style onload='this.onload=null,this.rel="stylesheet"' href=/lib/fontawesome-free/all.min.css><noscript><link rel=stylesheet href=/lib/fontawesome-free/all.min.css></noscript><link rel=preload as=style onload='this.onload=null,this.rel="stylesheet"' href=/lib/animate/animate.min.css><noscript><link rel=stylesheet href=/lib/animate/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Leveldb 源码详解系列之五: SSTable 设计与实现","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/chienlungcheung.github.io\/leveldb-annotations-5-sstable\/"},"genre":"posts","keywords":"leveldb, LSM-Tree, db, kv","wordcount":13702,"url":"https:\/\/chienlungcheung.github.io\/leveldb-annotations-5-sstable\/","datePublished":"2021-05-29T14:02:43+08:00","dateModified":"2021-05-29T14:02:43+08:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"Hari"},"description":""}</script><script src=//instant.page/5.1.1 defer type=module integrity=sha384-MWfCL6g1OTGsbSwfuMHc8+8J2u71/LA8dzlIN3ycajckxuZZmF+DNjdm7O6H3PSq></script></head><body header-desktop=fixed header-mobile=auto><script type=text/javascript>function setTheme(e){document.body.setAttribute("theme",e),document.documentElement.style.setProperty("color-scheme",e==="light"?"light":"dark"),window.theme=e}function saveTheme(e){window.localStorage&&localStorage.setItem("theme",e)}function getMeta(e){const t=document.getElementsByTagName("meta");for(let n=0;n<t.length;n++)if(t[n].getAttribute("name")===e)return t[n];return""}if(window.localStorage&&localStorage.getItem("theme")){let e=localStorage.getItem("theme");e==="light"||e==="dark"||e==="black"?setTheme(e):setTheme(window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light")}else"auto"==="light"||"auto"==="dark"||"auto"==="black"?(setTheme("auto"),saveTheme("auto")):(saveTheme("auto"),setTheme(window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light"));let metaColors={light:"#f8f8f8",dark:"#252627",black:"#000000"};getMeta("theme-color").content=metaColors[document.body.getAttribute("theme")]</script><div id=back-to-top></div><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title=二手知识>二手知识</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>文章 </a><a class=menu-item href=/tags/>标签 </a><a class=menu-item href=/categories/>分类 </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop>
<input type=text placeholder=搜索文章标题或内容... id=search-input-desktop>
<a href=# class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fas fa-search fa-fw"></i>
</a><a href=# class="search-button search-clear" id=search-clear-desktop title=清空><i class="fas fa-times-circle fa-fw"></i>
</a><span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin"></i>
</span></span><a href=# class="menu-item theme-select" title=切换主题><i class="fas fa-adjust fa-fw"></i>
<select class=color-theme-select id=theme-select-desktop title=切换主题><option value=light>浅色</option><option value=dark>深色</option><option value=black>黑色</option><option value=auto>跟随系统</option></select></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title=二手知识>二手知识</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容... id=search-input-mobile>
<a href=# class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fas fa-search fa-fw"></i>
</a><a href=# class="search-button search-clear" id=search-clear-mobile title=清空><i class="fas fa-times-circle fa-fw"></i>
</a><span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin"></i></span></div><a href=# class=search-cancel id=search-cancel-mobile>取消</a></div><a class=menu-item href=/posts/ title>文章</a><a class=menu-item href=/tags/ title>标签</a><a class=menu-item href=/categories/ title>分类</a><a href=# class="menu-item theme-select" title=切换主题>
<i class="fas fa-adjust fa-fw"></i>
<select class=color-theme-select id=theme-select-mobile title=切换主题><option value=light>浅色</option><option value=dark>深色</option><option value=black>黑色</option><option value=auto>跟随系统</option></select></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>目录</h2><div class=toc-content id=toc-content-auto><nav id=TableOfContents><ul><li><a href=#1-sstable-文件布局>1 sstable 文件布局</a><ul><li><a href=#11-data-block-布局>1.1 data block 布局</a></li><li><a href=#12-meta-block-布局>1.2 meta block 布局</a></li><li><a href=#13-meta-index-block-布局>1.3 meta-index block 布局</a></li><li><a href=#14-index-block-布局>1.4 index block 布局</a></li><li><a href=#15-footer-布局>1.5 footer 布局</a></li></ul></li><li><a href=#2-sstable-文件的序列化与反序列化>2 sstable 文件的序列化与反序列化</a><ul><li><a href=#21-sstable-文件序列化>2.1 sstable 文件序列化</a><ul><li><a href=#211-总干事-tablebuilder>2.1.1 总干事 TableBuilder</a><ul><li><a href=#2111-tablebuilder-的存储小助手-rep>2.1.1.1 TableBuilder 的存储小助手 Rep</a></li></ul></li><li><a href=#212-写-data-blocks>2.1.2 写 data blocks</a></li><li><a href=#213-写-metafilter-block>2.1.3 写 meta(filter) block</a></li><li><a href=#214-写-meta-index-block>2.1.4 写 meta-index block</a></li><li><a href=#215-写-data-index-block>2.1.5 写 data-index block</a></li><li><a href=#216-写-footer>2.1.6 写 footer</a></li></ul></li><li><a href=#22-sstable-文件反序列化>2.2 sstable 文件反序列化</a><ul><li><a href=#221-总干事-table-类>2.2.1 总干事 Table 类</a><ul><li><a href=#2211-table-类的小助手之一-rep>2.2.1.1 Table 类的小助手之一 Rep</a></li><li><a href=#2212-table-类的小助手之二-block>2.2.1.2 Table 类的小助手之二 Block</a></li></ul></li><li><a href=#222-读-footer>2.2.2 读 footer</a></li><li><a href=#223-读-data-index-block>2.2.3 读 data-index block</a></li><li><a href=#224-读-meta-index-block>2.2.4 读 meta-index block</a></li><li><a href=#225-读-meta-block>2.2.5 读 meta block</a></li><li><a href=#226-读-block-内容的通用方法>2.2.6 读 block 内容的通用方法</a></li></ul></li><li><a href=#23-table-和两级迭代器的结合>2.3 Table 和两级迭代器的结合</a></li></ul></li></ul></nav></div></div><script>document.getElementsByTagName("main")[0].setAttribute("autoTOC","true")</script><article class="page single"><h1 class="single-title animate__animated animate__flipInX">Leveldb 源码详解系列之五: SSTable 设计与实现</h1><div class=post-meta><div class=post-meta-line><span class=post-author><i class="author fas fa-user-circle fa-fw"></i><a href=/ title=Author rel=author class=author>Hari</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2021-05-29>2021-05-29</time>&nbsp;<i class="far fa-edit fa-fw"></i>&nbsp;<time datetime=2021-05-29>2021-05-29</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 13702 字&nbsp;
<i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 28 分钟&nbsp;</div></div><div class="details toc" id=toc-static kept><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fas fa-angle-right"></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#1-sstable-文件布局>1 sstable 文件布局</a><ul><li><a href=#11-data-block-布局>1.1 data block 布局</a></li><li><a href=#12-meta-block-布局>1.2 meta block 布局</a></li><li><a href=#13-meta-index-block-布局>1.3 meta-index block 布局</a></li><li><a href=#14-index-block-布局>1.4 index block 布局</a></li><li><a href=#15-footer-布局>1.5 footer 布局</a></li></ul></li><li><a href=#2-sstable-文件的序列化与反序列化>2 sstable 文件的序列化与反序列化</a><ul><li><a href=#21-sstable-文件序列化>2.1 sstable 文件序列化</a><ul><li><a href=#211-总干事-tablebuilder>2.1.1 总干事 TableBuilder</a><ul><li><a href=#2111-tablebuilder-的存储小助手-rep>2.1.1.1 TableBuilder 的存储小助手 Rep</a></li></ul></li><li><a href=#212-写-data-blocks>2.1.2 写 data blocks</a></li><li><a href=#213-写-metafilter-block>2.1.3 写 meta(filter) block</a></li><li><a href=#214-写-meta-index-block>2.1.4 写 meta-index block</a></li><li><a href=#215-写-data-index-block>2.1.5 写 data-index block</a></li><li><a href=#216-写-footer>2.1.6 写 footer</a></li></ul></li><li><a href=#22-sstable-文件反序列化>2.2 sstable 文件反序列化</a><ul><li><a href=#221-总干事-table-类>2.2.1 总干事 Table 类</a><ul><li><a href=#2211-table-类的小助手之一-rep>2.2.1.1 Table 类的小助手之一 Rep</a></li><li><a href=#2212-table-类的小助手之二-block>2.2.1.2 Table 类的小助手之二 Block</a></li></ul></li><li><a href=#222-读-footer>2.2.2 读 footer</a></li><li><a href=#223-读-data-index-block>2.2.3 读 data-index block</a></li><li><a href=#224-读-meta-index-block>2.2.4 读 meta-index block</a></li><li><a href=#225-读-meta-block>2.2.5 读 meta block</a></li><li><a href=#226-读-block-内容的通用方法>2.2.6 读 block 内容的通用方法</a></li></ul></li><li><a href=#23-table-和两级迭代器的结合>2.3 Table 和两级迭代器的结合</a></li></ul></li></ul></nav></div></div><div class=content id=content><p>leveldb, leveldb, 每个 level 保存的内容就是一组 sorted string table (简称 sstable) 文件.</p><h2 id=1-sstable-文件布局 class=headerLink><a href=#1-sstable-%e6%96%87%e4%bb%b6%e5%b8%83%e5%b1%80 class=header-mark></a>1 sstable 文件布局</h2><p>SSTable 即 sorted string table, 是一个有序文件格式.</p><p>该文件主要包含五个部分:</p><ul><li>一系列 data blocks, 这里保存的我们需要的数据.</li><li>一系列 meta blocks, 这里目前保存的只有布隆过滤器. 通过它, 在不解析 data blocks 的前提下就能知道某个 key 是否存在, 如果可能存在也能快速缩小到可能在哪个 data block.</li><li>一个 metaindex block, 包含指向 meta blocks 的索引.</li><li>一个 index block, 包含指向 data blocks 的索引.</li><li>一个 footer, sstable 文件入口, 保存着指向 metaindex block 和 index block 的索引, 相当于一个二级指针.</li></ul><p>不像 kafka 文件存储结构的数据文件和索引文件是各自独立的(在查询时根据具体 key 先在索引文件确定是哪个数据文件), sstable 把索引和数据保存到了同一个文件中. 每次从文件查询数据时会先查询索引, 索引是指向数据的指针, 具体叫做 BlockHandle, 包含着下述信息:</p><pre><code>// 目标 block 起始位置在文件中的偏移量
offset: varint64
// 目标 block 的大小
size:   varint64
</code></pre><p>形象地说, sstable 文件具体布局如下:</p><pre><code>&lt;beginning_of_file&gt;
[data block 1]
[data block 2]
...
[data block N]
[meta block 1]
...
[meta block K]
[metaindex block]
[index block]
[Footer]        (fixed size; starts at file_size - sizeof(Footer))
&lt;end_of_file&gt;
</code></pre><p>下面具体讲一下每个段的具体布局.</p><h3 id=11-data-block-布局 class=headerLink><a href=#11-data-block-%e5%b8%83%e5%b1%80 class=header-mark></a>1.1 data block 布局</h3><p>每个 block 包含的数据笼统地讲, 包含 <code>&lt;一系列数据项 + restart array + restart number></code> &ldquo;.</p><p>为了节省存储空间, block 中的数据项的 key 使用了前缀压缩. 具体来说, 存储某个 key 的时候先计算它和前一个数据项 key 的公共前缀长度, 公共前缀不再重复存储而是仅记录一个长度(shared), 由于 block 保存的数据是按 key 有序的, 排在一起的前缀都是比较相近的, 而且相似前缀可能还比较长所以该策略可以大幅节省存储空间.</p><p>block 中有一个至关重要的概念, 叫 <strong>restart point</strong>. 这个概念和前面提到的前缀压缩密切相关, 每个 block 的前缀压缩不是从第一个数据项开始就一直下去, 而是每隔一段(间隔可配置)设置一个新的前缀压缩起点(作为新起点的数据项的 key 保存原值而非做前缀压缩), restart point 指的就是新起点, 从这个地方开始继续做前缀压缩.</p><p>block 中每个数据项的格式如下:</p><ul><li>shared_bytes: varint32(与前一个 key 公共前缀的长度). 注意, 如果该数据项位于 restart 处, 则 shared_bytes 等于 0.</li><li>unshared_bytes: varint32(当前 key 除去公共前缀后的长度)</li><li>value_length: varint32(当前 key 对应的 value 的长度)</li><li>key_delta: char[unshared_bytes](当前 key 除去共享前缀后的字节内容)</li><li>value: char[value_length](当前 key 对应的 value 的数据内容)</li></ul><p>block 结尾处有个 trailer, 格式如下:</p><ul><li>restarts: uint32[num_restarts](保存 restart points 在 block 内偏移量的数组)</li><li>num_restarts: uint32(restart points 偏移量数组大小)
restarts[i] 保存的是第 i 个 restart point 在 block 内的偏移量.</li></ul><h3 id=12-meta-block-布局 class=headerLink><a href=#12-meta-block-%e5%b8%83%e5%b1%80 class=header-mark></a>1.2 meta block 布局</h3><p>它由 <code>&lt;一系列 filters + filter-offset 数组 + filters 部分的结束偏移量(4 字节) + base log 值(1 字节)></code> 构成. 注意该 block 最后 5 字节内容是固定的, 这也是该部分的解析入口.</p><p>该部分在写入文件时不进行压缩.</p><h3 id=13-meta-index-block-布局 class=headerLink><a href=#13-meta-index-block-%e5%b8%83%e5%b1%80 class=header-mark></a>1.3 meta-index block 布局</h3><p>只有一个数据项, key 为 <code>"filter."+过滤器名</code>, value 为 meta block 的 handle.</p><h3 id=14-index-block-布局 class=headerLink><a href=#14-index-block-%e5%b8%83%e5%b1%80 class=header-mark></a>1.4 index block 布局</h3><p>同 data block, 每个数据项的 key 是某个 data block 的最后一个 key, 每个数据项的 value 是这个 data block 的 handle. 注意, 由于该 block 数据项数和 data blocks 个数一样, 相对来说非常少, 所以就没做前缀压缩(具体实现就是将 restart point interval 设置为 1).</p><h3 id=15-footer-布局 class=headerLink><a href=#15-footer-%e5%b8%83%e5%b1%80 class=header-mark></a>1.5 footer 布局</h3><p>Footer 虽然位于 sstable 文件尾部, 但它是名副其实的文件入口, 它的<strong>长度固定</strong>, 很容易从文件尾定位到, 它包含:</p><ul><li>一个指向 metaindex block 的 BlockHandle</li><li>一个指向 index block 的 BlockHandle</li><li>一个 magic number.</li></ul><p>Footer 具体格式如下:</p><pre><code>// 指向 metaindex block 的 BlockHandle
metaindex_handle: char[p];     
// 指向 index block 的 BlockHandle
index_handle:     char[q];     
// 用于维持固定长度的 padding 0,
// (其中 40 == 2*BlockHandle::kMaxEncodedLength)
padding:          char[40-p-q];
// 具体内容为 0xdb4775248b80fb57 (小端字节序)
magic:            fixed64;     
</code></pre><p>注意 footer 存的都是 <em>index-of-xx</em>, 找到 <em>index</em> 就可以找到 <em>xx</em> 了.</p><p>关于 sstable 的其它细节请见 <a href=/leveldb-annotations-1-interfaces-and-files/ rel>Leveldb 源码详解系列之一: 接口与文件</a>.</p><p>了解了布局, 下面让我们来看看针对 sstable 的读写实现.</p><h2 id=2-sstable-文件的序列化与反序列化 class=headerLink><a href=#2-sstable-%e6%96%87%e4%bb%b6%e7%9a%84%e5%ba%8f%e5%88%97%e5%8c%96%e4%b8%8e%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96 class=header-mark></a>2 sstable 文件的序列化与反序列化</h2><p>sstable 文件集合保存着 leveldb 实例的数据, 定义在 <code>db/version_set.h</code> 中的 <code>class leveldb::Version</code> 跟踪每个 level 及其文件, 可以将这个类看做是对 leveldb 全部层级文件架构的抽象.</p><p>下面说明一下针对 sstable 文件的序列化和反序列化.</p><h3 id=21-sstable-文件序列化 class=headerLink><a href=#21-sstable-%e6%96%87%e4%bb%b6%e5%ba%8f%e5%88%97%e5%8c%96 class=header-mark></a>2.1 sstable 文件序列化</h3><p>完成该工作的是 <code>class leveldb::TableBuilder</code>, 该类负责构造 sstable 文件.</p><p>具体构造和写入顺序为:</p><ul><li>写 data blocks</li><li>写 meta blocks(目前仅有过滤器)</li><li>写 meta-index block</li><li>写 data-index block</li><li>写 footer</li></ul><p>每个分段也都有类似 XXBuilder 的类, 具体构造时会被 TableBuilder 调用. 除此之外, 还有一个类似的地方, 就是每个 XXBuilder 主要干活的基本都叫做 <code>Add()</code> 和 <code>Finish()</code> , 前者负责将具体数据添加到自己分段中, 后者负责将本段的元数据追加到自己分段尾部从而完成分段构造. 具体执行过程中, 各个 XXBuilder 有交叉的地方. 典型地, BlockBuilder 构造 data block 时会将自己的 BlockHandle 保存到 index block, 同时会将自己的 key 添加到 filter block 的相关状态里. 具体下面详述.</p><h4 id=211-总干事-tablebuilder class=headerLink><a href=#211-%e6%80%bb%e5%b9%b2%e4%ba%8b-tablebuilder class=header-mark></a>2.1.1 总干事 TableBuilder</h4><p>该类是构造 sstable 的入口, 外部(如 <code>leveldb::BuildTable()</code> 方法在被 <code>leveldb::DBImpl::WriteLevel0Table()</code> 方法调用将 memtable 转为 sstable 的时候)直接循环调用该类的 <code>Add()</code> 方法来向 sstable 追加 k,v 数据, 追加完毕后调用该类 <code>Finish()</code> 方法做收尾工作.</p><p>下面列出 TableBuilder 比较核心的成员:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// 该类用于构造 sstable(sorted string table) 文件. 
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>// 如果用户从多个线程调用该类的 const 方法, 线程安全; 
</span></span></span><span class=line><span class=cl><span class=c1>// 如果从多个线程调用非 const 方法, 则需要依赖外部同步设施确保线程安全. 
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>LEVELDB_EXPORT</span> <span class=n>TableBuilder</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 将一对 &lt;key,value&gt; 追加到正在构造的 table 中. 
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 要求 1: key 必须大于任何之前已经添加过的 keys, 
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>//        因为该文件是有序的.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 要求 2: 还没调用过 Finish() 或者 Abandon(), 
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>//        调用了这两个方法表示 table 对应文件被关掉了.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>void</span> <span class=n>Add</span><span class=p>(</span><span class=k>const</span> <span class=n>Slice</span><span class=o>&amp;</span> <span class=n>key</span><span class=p>,</span> <span class=k>const</span> <span class=n>Slice</span><span class=o>&amp;</span> <span class=n>value</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// 该方法由 Add() 和 Finish() 调用, 将缓冲的 data block 写入文件.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 要求: 还没调用过 Finish() 或者 Abandon(). 
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>void</span> <span class=nf>Flush</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// 完成 table 构建. 该方法返回后停止使用在构造方法中传入的文件. 
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 要求: 还没调用过 Finish() 或者 Abandon(). 
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// table 构成: data blocks, filter block, metaindex block, index block
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>Status</span> <span class=nf>Finish</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl> <span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 将 data block 内容根据设置进行压缩, 然后写入文件;
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 同时将 data block 在 table 偏移量和 size 设置到
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// handle 中, 写完 block 会将其 handle 写入
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// index block.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>void</span> <span class=n>WriteBlock</span><span class=p>(</span><span class=n>BlockBuilder</span><span class=o>*</span> <span class=n>block</span><span class=p>,</span> <span class=n>BlockHandle</span><span class=o>*</span> <span class=n>handle</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 将 block 及其 trailer(注意这个 trailer 不是 block 内部的 trailer)
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 写入 table 对应的文件, 
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 并将 block 对应的 BlockHandle 内容保存到 handle 中. 
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 写失败时该方法只将错误状态记录到 r-&gt;status, 不做其它任何处理.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 该方法由 WriteBlock 调用.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>void</span> <span class=nf>WriteRawBlock</span><span class=p>(</span><span class=k>const</span> <span class=n>Slice</span><span class=o>&amp;</span> <span class=n>data</span><span class=p>,</span> <span class=n>CompressionType</span><span class=p>,</span> <span class=n>BlockHandle</span><span class=o>*</span> <span class=n>handle</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 这个结构体很重要, 是 Table 实际存储数据的结构体, 下面单独开辟一节讲述.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>struct</span> <span class=nc>Rep</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 存储构造过程中的 table
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>Rep</span><span class=o>*</span> <span class=n>rep_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>主要方法有以下两个:</p><ul><li><code>void BlockBuilder::Add(const Slice& key, const Slice& value)</code> 负责向 TableBuilder 对象添加 (key, value), 该工作主要由 <code>class leveldb::BlockBuilder::Add()</code> 方法完成.</li><li><code>void leveldb::TableBuilder::Finish()</code> 负责将整个 Table 序列化为一个 sstable 文件并写入磁盘.</li></ul><p><code>Add()</code> 方法在构造 data block 和 index block 时用到了 <code>BlockBuilder</code> 对应方法, <code>Add()</code> 实现如下:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// 将一对 &lt;key,value&gt; 追加到正在构造的 table 中.
</span></span></span><span class=line><span class=cl><span class=c1>// 该方法追加数据时会同时影响到 data block, data index block, 
</span></span></span><span class=line><span class=cl><span class=c1>// meta block 的构造.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=n>TableBuilder</span><span class=o>::</span><span class=n>Add</span><span class=p>(</span><span class=k>const</span> <span class=n>Slice</span><span class=o>&amp;</span> <span class=n>key</span><span class=p>,</span> <span class=k>const</span> <span class=n>Slice</span><span class=o>&amp;</span> <span class=n>value</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>Rep</span><span class=o>*</span> <span class=n>r</span> <span class=o>=</span> <span class=n>rep_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 确保之前没有调用过 Finish() 或者 Abandon()
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>assert</span><span class=p>(</span><span class=o>!</span><span class=n>r</span><span class=o>-&gt;</span><span class=n>closed</span><span class=p>);</span> 
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>ok</span><span class=p>())</span> <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 如果该条件成立则说明之前调用过 Add 添加过数据了
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span> <span class=p>(</span><span class=n>r</span><span class=o>-&gt;</span><span class=n>num_entries</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span> 
</span></span><span class=line><span class=cl>    <span class=c1>// 确保待添加的 key 大于之前已添加过的全部 keys
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>assert</span><span class=p>(</span><span class=n>r</span><span class=o>-&gt;</span><span class=n>options</span><span class=p>.</span><span class=n>comparator</span><span class=o>-&gt;</span><span class=n>Compare</span><span class=p>(</span><span class=n>key</span><span class=p>,</span> <span class=n>Slice</span><span class=p>(</span><span class=n>r</span><span class=o>-&gt;</span><span class=n>last_key</span><span class=p>))</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>);</span> 
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// 需要构造一个新的 data block
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span> <span class=p>(</span><span class=n>r</span><span class=o>-&gt;</span><span class=n>pending_index_entry</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 与上面紧邻的这个判断条件构成不变式, 为空表示
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 已经将写满的 data block flush 到文件了.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>assert</span><span class=p>(</span><span class=n>r</span><span class=o>-&gt;</span><span class=n>data_block</span><span class=p>.</span><span class=n>empty</span><span class=p>());</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 为 pending index entry 选一个合适的 key.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 下面这个函数调用结束, last_key 可能不变, 也可能长度更短(省空间)但是值更大, 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 但不会 &gt;= 要追加的 key. 因为进入该方法之前关于两个参数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 已经有了一个约束: 第一个字符串肯定小于第二个字符串, 这个上面有断言保证了.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 为何这么做? 因为在查询数据时, 是先在 data-index block 中定位包含该数据的
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 目标 data block, 然后再转入目标 data block 中进行查找. 第一个定位靠的
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 就是这里的 last_key, 它和 data block 对应的 handle 一起构成了 data block 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 在 data-index block 中的数据项. 第一个定位主要过程就是在 data-index block 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 上查找第一个大于等于要查询数据的数据项, 具体见 TwoLevelIterator::Seek().  
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>r</span><span class=o>-&gt;</span><span class=n>options</span><span class=p>.</span><span class=n>comparator</span><span class=o>-&gt;</span><span class=n>FindShortestSeparator</span><span class=p>(</span><span class=o>&amp;</span><span class=n>r</span><span class=o>-&gt;</span><span class=n>last_key</span><span class=p>,</span> <span class=n>key</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 用于存储序列化后的 BlockHandle
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>handle_encoding</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 将刚刚 flush 过的 data block 对应的 BlockHandle 序列化
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>r</span><span class=o>-&gt;</span><span class=n>pending_handle</span><span class=p>.</span><span class=n>EncodeTo</span><span class=p>(</span><span class=o>&amp;</span><span class=n>handle_encoding</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// data index block 构造相关:
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 为刚刚 flush 过的 data block 在 index block 增加一个数据项, 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// last_key 肯定大于等于其全部所有的 keys 且小于新的 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// data block 的第一个 key.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>r</span><span class=o>-&gt;</span><span class=n>index_block</span><span class=p>.</span><span class=n>Add</span><span class=p>(</span><span class=n>r</span><span class=o>-&gt;</span><span class=n>last_key</span><span class=p>,</span> <span class=n>Slice</span><span class=p>(</span><span class=n>handle_encoding</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 增加过 index entry 后, 可以将其置为 false 了.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>r</span><span class=o>-&gt;</span><span class=n>pending_index_entry</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=c1>// meta block 构造相关:
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 如果该 table 存在 filter block, 则将该 key 加入.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// (filter block 可以用于快速定位 key 是否存在于 table 中).
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 加入的 key 在 FilterBlockBuilder 中使用.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span> <span class=p>(</span><span class=n>r</span><span class=o>-&gt;</span><span class=n>filter_block</span> <span class=o>!=</span> <span class=k>nullptr</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>r</span><span class=o>-&gt;</span><span class=n>filter_block</span><span class=o>-&gt;</span><span class=n>AddKey</span><span class=p>(</span><span class=n>key</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// 用新 key 更新 last_key
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>r</span><span class=o>-&gt;</span><span class=n>last_key</span><span class=p>.</span><span class=n>assign</span><span class=p>(</span><span class=n>key</span><span class=p>.</span><span class=n>data</span><span class=p>(),</span> <span class=n>key</span><span class=p>.</span><span class=n>size</span><span class=p>());</span>
</span></span><span class=line><span class=cl>  <span class=n>r</span><span class=o>-&gt;</span><span class=n>num_entries</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=c1>// data block 相关:
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 将 key,value 添加到 data block 中
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>r</span><span class=o>-&gt;</span><span class=n>data_block</span><span class=p>.</span><span class=n>Add</span><span class=p>(</span><span class=n>key</span><span class=p>,</span> <span class=n>value</span><span class=p>);</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=n>size_t</span> <span class=n>estimated_block_size</span> <span class=o>=</span> <span class=n>r</span><span class=o>-&gt;</span><span class=n>data_block</span><span class=p>.</span><span class=n>CurrentSizeEstimate</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 如果当前 data block 大小的估计值大于设定的阈值, 
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 则将该 data block 写入文件
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span> <span class=p>(</span><span class=n>estimated_block_size</span> <span class=o>&gt;=</span> <span class=n>r</span><span class=o>-&gt;</span><span class=n>options</span><span class=p>.</span><span class=n>block_size</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Flush</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><code>Add()</code> 在检测到 data block 大小达到阈值时会调用 <code>Flush()</code> 将数据刷入文件. 刷入完成, 会调用 FilterBlockBuilder 为其生成 filter. 具体如下:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// Add() 依赖 Flush() 将大小满足要求的 block 写入文件中.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=n>TableBuilder</span><span class=o>::</span><span class=n>Flush</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>Rep</span><span class=o>*</span> <span class=n>r</span> <span class=o>=</span> <span class=n>rep_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>assert</span><span class=p>(</span><span class=o>!</span><span class=n>r</span><span class=o>-&gt;</span><span class=n>closed</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>ok</span><span class=p>())</span> <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>r</span><span class=o>-&gt;</span><span class=n>data_block</span><span class=p>.</span><span class=n>empty</span><span class=p>())</span> <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>assert</span><span class=p>(</span><span class=o>!</span><span class=n>r</span><span class=o>-&gt;</span><span class=n>pending_index_entry</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 将 data block 压缩并落盘, 在该方法中 data_block 会调用 Reset()
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>WriteBlock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>r</span><span class=o>-&gt;</span><span class=n>data_block</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>r</span><span class=o>-&gt;</span><span class=n>pending_handle</span><span class=p>);</span> 
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>ok</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// flush 一个 data block, 就要在 index block 为其增加一个指针.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>r</span><span class=o>-&gt;</span><span class=n>pending_index_entry</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>r</span><span class=o>-&gt;</span><span class=n>status</span> <span class=o>=</span> <span class=n>r</span><span class=o>-&gt;</span><span class=n>file</span><span class=o>-&gt;</span><span class=n>Flush</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>r</span><span class=o>-&gt;</span><span class=n>filter_block</span> <span class=o>!=</span> <span class=k>nullptr</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 为已经刷入文件的 data block 计算 filter, 同时
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 为新的 data block 计算 filter 做准备, 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// r-&gt;offset 为下个 block 在 table 的起始地址, 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 该值在上面 WriteBlock 调用 WriteRawBlock 时会进行更新.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>r</span><span class=o>-&gt;</span><span class=n>filter_block</span><span class=o>-&gt;</span><span class=n>StartBlock</span><span class=p>(</span><span class=n>r</span><span class=o>-&gt;</span><span class=n>offset</span><span class=p>);</span> 
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h5 id=2111-tablebuilder-的存储小助手-rep class=headerLink><a href=#2111-tablebuilder-%e7%9a%84%e5%ad%98%e5%82%a8%e5%b0%8f%e5%8a%a9%e6%89%8b-rep class=header-mark></a>2.1.1.1 TableBuilder 的存储小助手 Rep</h5><p>从 TableBuilder 定义可以看到, private 部分有一个 Rep, 这是 TableBuilder 用于存放构造中的 sstable 的地方. 因为它太重要, 所以单独拿出来说一下:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>struct</span> <span class=nc>TableBuilder</span><span class=o>::</span><span class=n>Rep</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>Options</span> <span class=n>options</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>Options</span> <span class=n>index_block_options</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=c1>// table 对应的文件指针
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>WritableFile</span><span class=o>*</span> <span class=n>file</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>  <span class=c1>// table 文件当前的最大偏移量
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>uint64_t</span> <span class=n>offset</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>  <span class=n>Status</span> <span class=n>status</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 用于构造 data block
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>BlockBuilder</span> <span class=n>data_block</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>  <span class=c1>// 用于构造 data index block
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>BlockBuilder</span> <span class=n>index_block</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>  <span class=c1>// 最近一次成功调用 Add 添加的 key
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>last_key</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>  <span class=c1>// 当前 table 中全部 data block entries 个数
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>int64_t</span> <span class=n>num_entries</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>  <span class=c1>// 指示是否调用过 Finish() 或 Abandon()
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>bool</span> <span class=n>closed</span><span class=p>;</span>          
</span></span><span class=line><span class=cl>  <span class=c1>// 用于构造 filter block
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>FilterBlockBuilder</span><span class=o>*</span> <span class=n>filter_block</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// 直到当追加下一个 data block 第一个 key 的时候, 我们才会将
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 当前 data block 对应的 index 数据项追加到 index block,  
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 这样可以让我们在 index block 使用更短的 key. 
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 举个例子, 假设当前 data block 最后一个
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// key &#34;the quick brown fox&#34;, 下一个 data block 
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 首个 key &#34;the who&#34; 之间, 
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 则我们可以为当前 data block 的 index 数据项设置
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// key &#34;the r&#34;, 因为它 &gt;= 当前 data block 全部 key, 
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 而且 &lt; 接下来 data block 的全部 key. 
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 不变式: 仅当 data_block 为空的时候(已经被 flush 过了)
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// r-&gt;pending_index_entry 才为 true. 
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 注意该变量初始值为 false, 也就是写满(大小可配置)并 flush 过一个
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// data block 时候才会写入它对应的 index entry, 
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 因为此时 index entry 才知道 data block 最大 key 是什么.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>bool</span> <span class=n>pending_index_entry</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 与 pending_index_entry 配套, 
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 指向当前 data block 的 BlockHandle,
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 会被追加到 index block 中.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>BlockHandle</span> <span class=n>pending_handle</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>compressed_output</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>Rep</span><span class=p>(</span><span class=k>const</span> <span class=n>Options</span><span class=o>&amp;</span> <span class=n>opt</span><span class=p>,</span> <span class=n>WritableFile</span><span class=o>*</span> <span class=n>f</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=o>:</span> <span class=n>options</span><span class=p>(</span><span class=n>opt</span><span class=p>),</span>
</span></span><span class=line><span class=cl>        <span class=n>index_block_options</span><span class=p>(</span><span class=n>opt</span><span class=p>),</span>
</span></span><span class=line><span class=cl>        <span class=n>file</span><span class=p>(</span><span class=n>f</span><span class=p>),</span>
</span></span><span class=line><span class=cl>        <span class=n>offset</span><span class=p>(</span><span class=mi>0</span><span class=p>),</span>
</span></span><span class=line><span class=cl>        <span class=n>data_block</span><span class=p>(</span><span class=o>&amp;</span><span class=n>options</span><span class=p>),</span>
</span></span><span class=line><span class=cl>        <span class=n>index_block</span><span class=p>(</span><span class=o>&amp;</span><span class=n>index_block_options</span><span class=p>),</span>
</span></span><span class=line><span class=cl>        <span class=n>num_entries</span><span class=p>(</span><span class=mi>0</span><span class=p>),</span>
</span></span><span class=line><span class=cl>        <span class=n>closed</span><span class=p>(</span><span class=nb>false</span><span class=p>),</span>
</span></span><span class=line><span class=cl>        <span class=n>filter_block</span><span class=p>(</span><span class=n>opt</span><span class=p>.</span><span class=n>filter_policy</span> <span class=o>==</span> <span class=k>nullptr</span> <span class=o>?</span> <span class=k>nullptr</span>
</span></span><span class=line><span class=cl>                     <span class=o>:</span> <span class=k>new</span> <span class=n>FilterBlockBuilder</span><span class=p>(</span><span class=n>opt</span><span class=p>.</span><span class=n>filter_policy</span><span class=p>)),</span>
</span></span><span class=line><span class=cl>        <span class=n>pending_index_entry</span><span class=p>(</span><span class=nb>false</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// index block 的 key 不需要做前缀压缩, 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 所以把该值设置为 1, 表示每个 restart 段长度为 1.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>index_block_options</span><span class=p>.</span><span class=n>block_restart_interval</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=212-写-data-blocks class=headerLink><a href=#212-%e5%86%99-data-blocks class=header-mark></a>2.1.2 写 data blocks</h4><p>BlockBuilder 被 TableBuilder 使用来构造 sstable 文件里的 block, 注意, 该类用于构造 block 的序列化形式, 也就是构造 sstable 时候使用; 反序列化用的是 Block 类.</p><p>要理解这里必须要清楚 block 布局, 这个在文章开头有详细描述. 建议回过头看一眼, 尤其 restart point 的设计.</p><p>同 TableBuilder 类似, BlockBuilder 最重要的两个方法也是 <code>Add()</code> 和 <code>Finish()</code>. TableBuilder 会重复使用 BlockBuilder 实例, 每写入一个 block 就会调用其 <code>Reset()</code> 将其恢复原状.</p><p>BlockBuilder 核心成员如下:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>BlockBuilder</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=k>explicit</span> <span class=n>BlockBuilder</span><span class=p>(</span><span class=k>const</span> <span class=n>Options</span><span class=o>*</span> <span class=n>options</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// 重置 BlockBuilder 对象状态信息, 就像该对象刚刚被创建时一样. 
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>void</span> <span class=nf>Reset</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// 与 Finish() 分工, 负责追加一个数据项到 buffer. 
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 前提: 
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 1. 自从上次调用 Reset() 还未调用过 Finish(); 
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 2. 参数 key 要大于任何之前已经添加过的数据项的 key,
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 因为这是一个 append 类型操作. 
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>void</span> <span class=nf>Add</span><span class=p>(</span><span class=k>const</span> <span class=n>Slice</span><span class=o>&amp;</span> <span class=n>key</span><span class=p>,</span> <span class=k>const</span> <span class=n>Slice</span><span class=o>&amp;</span> <span class=n>value</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// 该方法负责 block 构建的收尾工作, 具体是将 restart points
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 数组及其长度追加到 block 的数据内容之后完成构建工作, 最后返回
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 一个指向 block 全部内容的 slice. 
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 返回的 slice 生命期同当前 builder, 若 builder 调用了
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// Reset() 方法则返回的 slice 失效. 
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>Slice</span> <span class=nf>Finish</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl> <span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 存储目标 block 内容的缓冲区
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>std</span><span class=o>::</span><span class=n>string</span>           <span class=n>buffer_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 存储目标 block 的全部 restart points
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// (即每个 restart point 在 block 中的偏移量, 
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 第一个 restart point 偏移量为 0)
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>uint32_t</span><span class=o>&gt;</span> <span class=n>restarts_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 该 BlockBuilder 上次调用 Add 时追加的那个 key
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>std</span><span class=o>::</span><span class=n>string</span>           <span class=n>last_key_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>最重要的 <code>Add()</code> 和 <code>Finish()</code> 实现如下:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span><span class=lnt>70
</span><span class=lnt>71
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=n>BlockBuilder</span><span class=o>::</span><span class=n>Add</span><span class=p>(</span><span class=k>const</span> <span class=n>Slice</span><span class=o>&amp;</span> <span class=n>key</span><span class=p>,</span> <span class=k>const</span> <span class=n>Slice</span><span class=o>&amp;</span> <span class=n>value</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 上次调用 Add 追加的 key, 用于计算公共前缀
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>Slice</span> <span class=nf>last_key_piece</span><span class=p>(</span><span class=n>last_key_</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 不能往一个完成构建的 block 里追加数据.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>assert</span><span class=p>(</span><span class=o>!</span><span class=n>finished_</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 自上个 restart 之后追加的 key 的个数没有超过要求的两个
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// restart points 之间 keys 的个数.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>assert</span><span class=p>(</span><span class=n>counter_</span> <span class=o>&lt;=</span> <span class=n>options_</span><span class=o>-&gt;</span><span class=n>block_restart_interval</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 当前要追加的 key 要大于任何之前追加到 buffer 中的 key
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>assert</span><span class=p>(</span><span class=n>buffer_</span><span class=p>.</span><span class=n>empty</span><span class=p>()</span> <span class=c1>// No values yet?
</span></span></span><span class=line><span class=cl><span class=c1></span>         <span class=o>||</span> <span class=n>options_</span><span class=o>-&gt;</span><span class=n>comparator</span><span class=o>-&gt;</span><span class=n>Compare</span><span class=p>(</span><span class=n>key</span><span class=p>,</span> <span class=n>last_key_piece</span><span class=p>)</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>size_t</span> <span class=n>shared</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 如果自上个 restart 之后追加的 key 的个数小于所配置的
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 两个相邻 restart 之间 keys 的个数. 
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span> <span class=p>(</span><span class=n>counter_</span> <span class=o>&lt;</span> <span class=n>options_</span><span class=o>-&gt;</span><span class=n>block_restart_interval</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=n>size_t</span> <span class=n>min_length</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>min</span><span class=p>(</span><span class=n>last_key_piece</span><span class=p>.</span><span class=n>size</span><span class=p>(),</span> <span class=n>key</span><span class=p>.</span><span class=n>size</span><span class=p>());</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 计算当前要追加的 key 与上次追加的 key 的公共前缀长度. 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>while</span> <span class=p>((</span><span class=n>shared</span> <span class=o>&lt;</span> <span class=n>min_length</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>last_key_piece</span><span class=p>[</span><span class=n>shared</span><span class=p>]</span> <span class=o>==</span> <span class=n>key</span><span class=p>[</span><span class=n>shared</span><span class=p>]))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>shared</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 否则, 新增一个 restart point, 而且作为 restart 的 key 不进行压缩. 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// - restart 就是一个 offset, 具体值为当前 buffer 所占空间大小. 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// - restart 后第一个数据项的 key 不进行压缩, 即不计算与前一个 key 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//   的公共前缀了, 而是把这个 key 整个保存起来, 但是本 &#34;restart&#34;  
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//   段, 从这个 key 开始后面的 keys 都要进行压缩.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>restarts_</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>buffer_</span><span class=p>.</span><span class=n>size</span><span class=p>());</span>
</span></span><span class=line><span class=cl>    <span class=n>counter_</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=n>size_t</span> <span class=n>non_shared</span> <span class=o>=</span> <span class=n>key</span><span class=p>.</span><span class=n>size</span><span class=p>()</span> <span class=o>-</span> <span class=n>shared</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Add &#34;&lt;shared&gt;&lt;non_shared&gt;&lt;value_size&gt;&#34; to buffer_
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// buffer 里面的每个记录的格式为: 
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// &lt;varint32 类型的当前 key 与上个 key 公共前缀长度&gt;
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// &lt;varint32 类型的当前 key 长度减去公共前缀后的长度&gt;
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// &lt;varint32 类型的当前 value 的长度&gt;
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// &lt;与前一个 key 公共前缀之后的部分&gt;
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// &lt;value&gt;
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>PutVarint32</span><span class=p>(</span><span class=o>&amp;</span><span class=n>buffer_</span><span class=p>,</span> <span class=n>shared</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>PutVarint32</span><span class=p>(</span><span class=o>&amp;</span><span class=n>buffer_</span><span class=p>,</span> <span class=n>non_shared</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>PutVarint32</span><span class=p>(</span><span class=o>&amp;</span><span class=n>buffer_</span><span class=p>,</span> <span class=n>value</span><span class=p>.</span><span class=n>size</span><span class=p>());</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// 将 key 非公共部分和 value 追加到 buffer_
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>buffer_</span><span class=p>.</span><span class=n>append</span><span class=p>(</span><span class=n>key</span><span class=p>.</span><span class=n>data</span><span class=p>()</span> <span class=o>+</span> <span class=n>shared</span><span class=p>,</span> <span class=n>non_shared</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>buffer_</span><span class=p>.</span><span class=n>append</span><span class=p>(</span><span class=n>value</span><span class=p>.</span><span class=n>data</span><span class=p>(),</span> <span class=n>value</span><span class=p>.</span><span class=n>size</span><span class=p>());</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// 更新状态
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>last_key_</span><span class=p>.</span><span class=n>resize</span><span class=p>(</span><span class=n>shared</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 将 last_key 更新为当前 key
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>last_key_</span><span class=p>.</span><span class=n>append</span><span class=p>(</span><span class=n>key</span><span class=p>.</span><span class=n>data</span><span class=p>()</span> <span class=o>+</span> <span class=n>shared</span><span class=p>,</span> <span class=n>non_shared</span><span class=p>);</span> 
</span></span><span class=line><span class=cl>  <span class=n>assert</span><span class=p>(</span><span class=n>Slice</span><span class=p>(</span><span class=n>last_key_</span><span class=p>)</span> <span class=o>==</span> <span class=n>key</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 将自上个 restart 之后的记录数加一
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>counter_</span><span class=o>++</span><span class=p>;</span> 
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Slice</span> <span class=n>BlockBuilder</span><span class=o>::</span><span class=n>Finish</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>   * 先将 restarts 数组编码后追加到 buffer, 
</span></span></span><span class=line><span class=cl><span class=cm>   * 然后将 restarts 数组长度编码后追加到 buffer 并将 finished 置位, 
</span></span></span><span class=line><span class=cl><span class=cm>   * 最后根据 buffer 构造一个新的 slice 返回(注意该 slice 引用的内存是 
</span></span></span><span class=line><span class=cl><span class=cm>   * buffer, 所以生命期同 builder, 除非 builder 调用了 Reset)
</span></span></span><span class=line><span class=cl><span class=cm>   */</span>
</span></span><span class=line><span class=cl>  <span class=c1>// Append restart array
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>for</span> <span class=p>(</span><span class=n>size_t</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>restarts_</span><span class=p>.</span><span class=n>size</span><span class=p>();</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>PutFixed32</span><span class=p>(</span><span class=o>&amp;</span><span class=n>buffer_</span><span class=p>,</span> <span class=n>restarts_</span><span class=p>[</span><span class=n>i</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=n>PutFixed32</span><span class=p>(</span><span class=o>&amp;</span><span class=n>buffer_</span><span class=p>,</span> <span class=n>restarts_</span><span class=p>.</span><span class=n>size</span><span class=p>());</span>
</span></span><span class=line><span class=cl>  <span class=n>finished_</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nf>Slice</span><span class=p>(</span><span class=n>buffer_</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=213-写-metafilter-block class=headerLink><a href=#213-%e5%86%99-metafilter-block class=header-mark></a>2.1.3 写 meta(filter) block</h4><p>不同于 data block 和 data index block, filter block 有专用的 builder, 叫做 <code>FilterBlockBuilder</code>. 它的核心方法是 <code>AddKey()</code> 和 <code>Finish()</code>.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// 该类在其它地方定义. 用于定义过滤器逻辑.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>FilterPolicy</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// FilterBlockBuilder 用于构造 table 的全部 filters. 
</span></span></span><span class=line><span class=cl><span class=c1>// 最后生成一个字符串保存在 Table 的一个 meta block 中. 
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>// 该类的方法调用序列必须满足下面的正则表达式: 
</span></span></span><span class=line><span class=cl><span class=c1>//      (StartBlock AddKey*)* Finish
</span></span></span><span class=line><span class=cl><span class=c1>// 最少调用一次 Finish, 而且 AddKey 和 Finish 之间不能插入 StartBlock 调用. 
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>FilterBlockBuilder</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=k>explicit</span> <span class=n>FilterBlockBuilder</span><span class=p>(</span><span class=k>const</span> <span class=n>FilterPolicy</span><span class=o>*</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=nf>StartBlock</span><span class=p>(</span><span class=kt>uint64_t</span> <span class=n>block_offset</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=nf>AddKey</span><span class=p>(</span><span class=k>const</span> <span class=n>Slice</span><span class=o>&amp;</span> <span class=n>key</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>Slice</span> <span class=nf>Finish</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl> <span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=n>GenerateFilter</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=n>FilterPolicy</span><span class=o>*</span> <span class=n>policy_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 调用 AddKey() 时每个 key 都会被
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 追加到这个字符串中(用于后续构造 filter 使用)
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>keys_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 与 keys_ 配套, 每个被 AddKey() 方法追加的 key 在 
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// keys_ 中的起始索引.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>size_t</span><span class=o>&gt;</span> <span class=n>start_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 每个新计算出来的 filter 都是一个字符串, 
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 都会被追加到 result_ 中.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// filter block 保存的内容就是 result_.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>result_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 是 keys_ 的列表形式, 临时变量, 每个成员是 Slice 类型,
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 用于 policy_-&gt;CreateFilter() 生成构造器.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>Slice</span><span class=o>&gt;</span> <span class=n>tmp_keys_</span><span class=p>;</span>   
</span></span><span class=line><span class=cl>  <span class=c1>// 与 result_ 配套, 保存每个 filter 在 result_ 
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 中的起始偏移量.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>uint32_t</span><span class=o>&gt;</span> <span class=n>filter_offsets_</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// No copying allowed
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>FilterBlockBuilder</span><span class=p>(</span><span class=k>const</span> <span class=n>FilterBlockBuilder</span><span class=o>&amp;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>FilterBlockBuilder</span><span class=o>&amp;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p><code>TableBuilder::Add()</code> 会在追加 k,v 的时候调用 FilterBlockBuilder 的
<code>AddKey()</code> 将 k 追加到 FilterBlockBuilder 中, 其实现逻辑比较简单:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// 向 keys_ 中增加一个 key, 同时将 key 在 keys_ 中
</span></span></span><span class=line><span class=cl><span class=c1>// 起始偏移量保存到 start_ 向量中.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=n>FilterBlockBuilder</span><span class=o>::</span><span class=n>AddKey</span><span class=p>(</span><span class=k>const</span> <span class=n>Slice</span><span class=o>&amp;</span> <span class=n>key</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>Slice</span> <span class=n>k</span> <span class=o>=</span> <span class=n>key</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>start_</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>keys_</span><span class=p>.</span><span class=n>size</span><span class=p>());</span>
</span></span><span class=line><span class=cl>  <span class=n>keys_</span><span class=p>.</span><span class=n>append</span><span class=p>(</span><span class=n>k</span><span class=p>.</span><span class=n>data</span><span class=p>(),</span> <span class=n>k</span><span class=p>.</span><span class=n>size</span><span class=p>());</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>当 TableBuilder flush 一个 data block 到文件后, 就要为其生成 filter, 该过程通过调用 FilterBlockBuilder 的 <code>StartBlock()</code> 达成:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// 为前一个已写入 table 文件的 data block 生成
</span></span></span><span class=line><span class=cl><span class=c1>// filter, 生成完毕后重置当前 FilterBlockBuilder 的状态为生成下一个
</span></span></span><span class=line><span class=cl><span class=c1>// filter 做准备.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=n>FilterBlockBuilder</span><span class=o>::</span><span class=n>StartBlock</span><span class=p>(</span><span class=kt>uint64_t</span> <span class=n>block_offset</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 计算以 block_offset 为起始地址的 block 对应的 filter 在
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// filter-offset 数组中的索引.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 默认每两 KB 数据就要生成一个 filter, 
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 如果 block size 超过 2KB, 则会生成多个 filters.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>uint64_t</span> <span class=n>filter_index</span> <span class=o>=</span> <span class=p>(</span><span class=n>block_offset</span> <span class=o>/</span> <span class=n>kFilterBase</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>assert</span><span class=p>(</span><span class=n>filter_index</span> <span class=o>&gt;=</span> <span class=n>filter_offsets_</span><span class=p>.</span><span class=n>size</span><span class=p>());</span>
</span></span><span class=line><span class=cl>  <span class=c1>// filter 是一个接一个构造的, 对应的索引数组也是对应着逐渐增长的, 
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 而非一次性构造好往里面填, 毕竟不知道要生成多少个 filters
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>while</span> <span class=p>(</span><span class=n>filter_index</span> <span class=o>&gt;</span> <span class=n>filter_offsets_</span><span class=p>.</span><span class=n>size</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 这里虽然是个循环, 但是因为每次生成 filter 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 都会清空相关状态(keys_, start_ 等等), 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 所以下个循环并不会再生成 filter 了, 具体见
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// GenerateFilter() 的 if 部分.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>GenerateFilter</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><code>StartBlock()</code> 方法有个循环调用 <code>GenerateFilter()</code> 方法的地方, 比较绕, 这部分逻辑要结合 <code>GenerateFilter()</code> if 部分和 <code>FilterBlockReader::KeyMayMatch()</code> 的 limit 计算部分一起看:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// 由于即将生成的 block 不能与当前已写入 table 文件的 block 
</span></span></span><span class=line><span class=cl><span class=c1>// 的 keys 共用 filter 了, 所以为当前已写入 table 文件的 block 的 
</span></span></span><span class=line><span class=cl><span class=c1>// keys_ 生成一个 filter. 生成完毕后清空当前 FilterBlockBuilder 
</span></span></span><span class=line><span class=cl><span class=c1>// 相关相关状态以为下个 filter 计算所用.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=n>FilterBlockBuilder</span><span class=o>::</span><span class=n>GenerateFilter</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// keys_ 为空, 无须生成新的 filter.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>const</span> <span class=n>size_t</span> <span class=n>num_keys</span> <span class=o>=</span> <span class=n>start_</span><span class=p>.</span><span class=n>size</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>num_keys</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 没有 key 需要计算 filter, 则直接把上一个 filter 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 的结束地址(每个 filter 都是一个字符串, 所以保存到 result_ 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 时候既有起始地址又有结束地址)填充到 filter-offset 数组中,
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 这么做一方面为了对齐(方便 FilterBlockReader::KeyMayMatch() 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 直接通过移位计算 filter 索引), 另一方面方便计算 filter 结束偏移量(
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 就是 FilterBlockReader::KeyMayMatch() 计算 limit 的步骤).
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>filter_offsets_</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>result_</span><span class=p>.</span><span class=n>size</span><span class=p>());</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// 将扁平化的 keys_ 转换为一个 key 列表.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 将 keys_ 大小放到 start_ 中作为最后一个 key 的结束地址, 
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 这样下面可以直接用 start_[i+1] - start_[i] 计算
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 每个 key 长度.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>start_</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>keys_</span><span class=p>.</span><span class=n>size</span><span class=p>());</span>  
</span></span><span class=line><span class=cl>  <span class=n>tmp_keys_</span><span class=p>.</span><span class=n>resize</span><span class=p>(</span><span class=n>num_keys</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 将字符串 keys_ 保存的每个 key 提取出来封装
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 成 Slice 并放到 tmp_keys 列表中
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>for</span> <span class=p>(</span><span class=n>size_t</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>num_keys</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 第 i 个 key 在 keys 中的起始地址
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>base</span> <span class=o>=</span> <span class=n>keys_</span><span class=p>.</span><span class=n>data</span><span class=p>()</span> <span class=o>+</span> <span class=n>start_</span><span class=p>[</span><span class=n>i</span><span class=p>];</span> 
</span></span><span class=line><span class=cl>    <span class=c1>// 第 i 个 key 的长度
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>size_t</span> <span class=n>length</span> <span class=o>=</span> <span class=n>start_</span><span class=p>[</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>]</span> <span class=o>-</span> <span class=n>start_</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 将第 i 个 key 封装成 Slice 并保存到 tmp_keys 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 用于后续计算 filter 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>tmp_keys_</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>Slice</span><span class=p>(</span><span class=n>base</span><span class=p>,</span> <span class=n>length</span><span class=p>);</span> 
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// 为当前的 key 集合生成 filter.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 先将新生成的 filter 在 result_ 中的
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 起始偏移量保存到 filter_offsets_.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>filter_offsets_</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>result_</span><span class=p>.</span><span class=n>size</span><span class=p>());</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 根据 tmp_keys_ 计算 filter 并追加到 result
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>policy_</span><span class=o>-&gt;</span><span class=n>CreateFilter</span><span class=p>(</span><span class=o>&amp;</span><span class=n>tmp_keys_</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>(</span><span class=n>num_keys</span><span class=p>),</span> <span class=o>&amp;</span><span class=n>result_</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// 重置当前 FilterBlockBuilder 相关的状态以方便为
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 下个 data block 计算 filter 使用.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>tmp_keys_</span><span class=p>.</span><span class=n>clear</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=n>keys_</span><span class=p>.</span><span class=n>clear</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=n>start_</span><span class=p>.</span><span class=n>clear</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>与 FilterBlockBuilder 相反, 将一个 filter block 解析出来, 然后用来查询某个 key 是否在某个 block 中. 其成员 <code>data_</code> 指向 filter block 起始地址, <code>offset_</code> 指向 filter block 尾部 offset array 的起始地址, 这也是 filter block 的末尾:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// 通过过滤器查询 key 是否在以 block_offset 为起始地址的 block 中
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>bool</span> <span class=n>FilterBlockReader</span><span class=o>::</span><span class=n>KeyMayMatch</span><span class=p>(</span><span class=kt>uint64_t</span> <span class=n>block_offset</span><span class=p>,</span> <span class=k>const</span> <span class=n>Slice</span><span class=o>&amp;</span> <span class=n>key</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 计算 filter 的时候是每隔 base 大小为一个区间, 
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 每个区间对应一个 filter. 
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 起始偏移量落在对应区间内的 blocks, 
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 会将其全部 keys 作为整体输入计算一个 filter. 
</span></span></span><span class=line><span class=cl><span class=c1></span>  
</span></span><span class=line><span class=cl>  <span class=c1>// 注意, 这里的算法正好解答了 
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// leveldb::FilterBlockBuilder::GenerateFilter() 的疑问, 
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 针对多出来那个重复的 filter offset, 会被自动跳过.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 下面这一步相当于除以 base 取商, 从而得到 block_offset 
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 对应的 filter-offset array 数组索引. 
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>uint64_t</span> <span class=n>index</span> <span class=o>=</span> <span class=n>block_offset</span> <span class=o>&gt;&gt;</span> <span class=n>base_lg_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>index</span> <span class=o>&lt;</span> <span class=n>num_</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 计算计算索引为 index 的 filter 的 offset, 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 具体为先定位到保存目标 filter offset 的地址(每个地址长度为 4 字节), 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 然后将其解码为一个无符号 32 位数.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>uint32_t</span> <span class=n>start</span> <span class=o>=</span> <span class=n>DecodeFixed32</span><span class=p>(</span><span class=n>offset_</span> <span class=o>+</span> <span class=n>index</span><span class=o>*</span><span class=mi>4</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 下面这个计算分两种情况理解:
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// - 当 index &lt; num_ - 1 时, 又要分为两个子情况
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//   - 如果 GenerateFilter() 方法在生成索引为 index 的 filter 时,
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//     至少多填充了一次 filter 结束偏移量到 filter-offset 数组, 那么
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//     该操作等价于取出索引为 index 的 filter 的结束偏移量
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//    (注意 GenerateFilter() 方法填充 filter 结束地址到
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//   filter-offset 的情况)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//   - 如果 GenerateFilter() 方法在生成索引为 index 的 filter 时, 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//     仅为该 filter 在 filter-offset 数组填入了起始偏移量, 那么该操作
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//     相当于计算索引为 index+1 的 filter 的起始 offset.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// - 当 index == num_ - 1 时, 也要再分为两个子情况
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//   - 同 index &lt; num_ - 1 时的第一个子情况.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//   - 如果 GenerateFilter() 方法在生成索引为 index 的 filter 时, 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//     仅为该 filter 在 filter-offset 数组填入了起始偏移量, 那么该操作
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//     等价于直接取出索引为 index 的 filter 的结束偏移量. 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//     为什么看起来和第一个子情况一样? 其实不然. 因为 filter block 构成分四块, 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//     分别是&#34;一系列filters+filters-offset数组+filters和filters-offset
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//     数组的分隔符+base的log值&#34;, 这里提到的分隔符用的就是
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//     最后一个 filter 的结束地址). 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 不管是哪种情况, limit - start 都是索引为 index 的 filter 的长度.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>uint32_t</span> <span class=n>limit</span> <span class=o>=</span> <span class=n>DecodeFixed32</span><span class=p>(</span><span class=n>offset_</span> <span class=o>+</span> <span class=n>index</span><span class=o>*</span><span class=mi>4</span> <span class=o>+</span> <span class=mi>4</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 注意 start 和 limit 都是相对于 data_ 的 offset 而非绝对地址.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>start</span> <span class=o>&lt;=</span> <span class=n>limit</span> <span class=o>&amp;&amp;</span> <span class=n>limit</span> <span class=o>&lt;=</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=n>size_t</span><span class=o>&gt;</span><span class=p>(</span><span class=n>offset_</span> <span class=o>-</span> <span class=n>data_</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=c1>// 取出 filter
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=n>Slice</span> <span class=n>filter</span> <span class=o>=</span> <span class=n>Slice</span><span class=p>(</span><span class=n>data_</span> <span class=o>+</span> <span class=n>start</span><span class=p>,</span> <span class=n>limit</span> <span class=o>-</span> <span class=n>start</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=c1>// 在 filter 中查询 key 是否存在
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=k>return</span> <span class=n>policy_</span><span class=o>-&gt;</span><span class=n>KeyMayMatch</span><span class=p>(</span><span class=n>key</span><span class=p>,</span> <span class=n>filter</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=nf>if</span> <span class=p>(</span><span class=n>start</span> <span class=o>==</span> <span class=n>limit</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=c1>// 如果 start == limit 说明索引为 index 的 filter 为空
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>TableBuilder 的 Finish() 会调用 FilterBlockBuilder 的 Finish() 完成 filter block 写入:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// 计算最后一个 filter 对应的偏移量, 然后将 
</span></span></span><span class=line><span class=cl><span class=c1>// filter-offset array 并追加到 result_.
</span></span></span><span class=line><span class=cl><span class=c1>// 执行结束, result_ 保存的就是一个完整的 filter block
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Slice</span> <span class=n>FilterBlockBuilder</span><span class=o>::</span><span class=n>Finish</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 若 keys_ 不为空需要为其生成一个 filter
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>start_</span><span class=p>.</span><span class=n>empty</span><span class=p>())</span> <span class=p>{</span> 
</span></span><span class=line><span class=cl>    <span class=n>GenerateFilter</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// 下面马上会把每个 filter 在 result_ 中对应的
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 起始地址也编码追加到 result_ 中, 这样前面是 filters, 
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 后面是 filters 的起始偏移量, 那这两部分反序列化时候怎么区分呢?
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 我们提前记录追加 filters 总字节数就可以了.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// array_offset 保存全部 filters 的总字节数, 
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 这个值在追加完全部 filters 
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 的起始地址后也会被追加到 result_ 作为最后一个元素, 
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 也是反序列化解析入口.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>const</span> <span class=kt>uint32_t</span> <span class=n>array_offset</span> <span class=o>=</span> <span class=n>result_</span><span class=p>.</span><span class=n>size</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 将每个 filter 在 result_ 中的起始偏移量编码追加到 result_
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>for</span> <span class=p>(</span><span class=n>size_t</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>filter_offsets_</span><span class=p>.</span><span class=n>size</span><span class=p>();</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>PutFixed32</span><span class=p>(</span><span class=o>&amp;</span><span class=n>result_</span><span class=p>,</span> <span class=n>filter_offsets_</span><span class=p>[</span><span class=n>i</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// 将 filter-offset array 的起始偏移量编码追加到 result_, 
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 用于反序列化时区分 filters 与 filters 偏移量数组.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>PutFixed32</span><span class=p>(</span><span class=o>&amp;</span><span class=n>result_</span><span class=p>,</span> <span class=n>array_offset</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 将 base 的 log 值追加到 result, 用于反序列化时计算 base
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>result_</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>kFilterBaseLg</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 到此为止, result_ 已经是一个完整的 filter block 了, 
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 将其封装为 Slice 后返回.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>return</span> <span class=nf>Slice</span><span class=p>(</span><span class=n>result_</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>最终在 TableBuilder 的 Finish() 将 filter block 刷入文件:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// 2 如果存在 filter block, 则将其写入文件; 
</span></span></span><span class=line><span class=cl><span class=c1>// 写完后, filter_block_handle 保存着该 block 
</span></span></span><span class=line><span class=cl><span class=c1>// 对应的 BlockHandle 信息, 包括起始偏移量和大小
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=p>(</span><span class=n>ok</span><span class=p>()</span> <span class=o>&amp;&amp;</span> <span class=n>r</span><span class=o>-&gt;</span><span class=n>filter_block</span> <span class=o>!=</span> <span class=k>nullptr</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 写完 data blocks 该写入 filter block 了.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 注意 filter block 写入时不进行压缩.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>WriteRawBlock</span><span class=p>(</span><span class=n>r</span><span class=o>-&gt;</span><span class=n>filter_block</span><span class=o>-&gt;</span><span class=n>Finish</span><span class=p>(),</span> <span class=n>kNoCompression</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>  <span class=c1>// 将计算出 filter block 对应的 BlockHandle 
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 信息保存在 filter_block_handle 中.
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=o>&amp;</span><span class=n>filter_block_handle</span><span class=p>);</span> 
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=214-写-meta-index-block class=headerLink><a href=#214-%e5%86%99-meta-index-block class=header-mark></a>2.1.4 写 meta-index block</h4><p>这部分比较简单, 其在 TableBuilder 的 Finish() 方法里完成:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// 3 filter block 就是 table_format.md 中提到的 
</span></span></span><span class=line><span class=cl><span class=c1>// meta block, 写完 meta block 该写它对应的索引
</span></span></span><span class=line><span class=cl><span class=c1>// metaindex block 到文件中了.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=p>(</span><span class=n>ok</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 虽然 meta block 有独立的 FilterBlockBuilder, 
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 但是其对应的 index block 用的还是通用的 
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// BlockBuilder.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>BlockBuilder</span> <span class=nf>meta_index_block</span><span class=p>(</span><span class=o>&amp;</span><span class=n>r</span><span class=o>-&gt;</span><span class=n>options</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>r</span><span class=o>-&gt;</span><span class=n>filter_block</span> <span class=o>!=</span> <span class=k>nullptr</span><span class=p>)</span> <span class=p>{</span> 
</span></span><span class=line><span class=cl>    <span class=c1>// 如果 meta block 存在, 则将其对应的 key 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 和 BlockHandle 写入 metaindex block,
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 具体为 &lt;filter.Name, filter 数据地址&gt;.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>key</span> <span class=o>=</span> <span class=s>&#34;filter.&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>key</span><span class=p>.</span><span class=n>append</span><span class=p>(</span><span class=n>r</span><span class=o>-&gt;</span><span class=n>options</span><span class=p>.</span><span class=n>filter_policy</span><span class=o>-&gt;</span><span class=n>Name</span><span class=p>());</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>handle_encoding</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>filter_block_handle</span><span class=p>.</span><span class=n>EncodeTo</span><span class=p>(</span><span class=o>&amp;</span><span class=n>handle_encoding</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>meta_index_block</span><span class=p>.</span><span class=n>Add</span><span class=p>(</span><span class=n>key</span><span class=p>,</span> <span class=n>handle_encoding</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 将 metaindex block 写入文件
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>WriteBlock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>meta_index_block</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>metaindex_block_handle</span><span class=p>);</span> 
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=215-写-data-index-block class=headerLink><a href=#215-%e5%86%99-data-index-block class=header-mark></a>2.1.5 写 data-index block</h4><p>这部分比较简单, 其在 TableBuilder 的 Finish() 方法里完成:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// 4 将 index block 写入 table 文件, 它里面保存的
</span></span></span><span class=line><span class=cl><span class=c1>// 都是 data block 对应的 BlockHandle.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=p>(</span><span class=n>ok</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 最后构建的 data block 对应的 index block entry 还没有写入
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span> <span class=p>(</span><span class=n>r</span><span class=o>-&gt;</span><span class=n>pending_index_entry</span><span class=p>)</span> <span class=p>{</span> 
</span></span><span class=line><span class=cl>    <span class=n>r</span><span class=o>-&gt;</span><span class=n>options</span><span class=p>.</span><span class=n>comparator</span><span class=o>-&gt;</span><span class=n>FindShortSuccessor</span><span class=p>(</span><span class=o>&amp;</span><span class=n>r</span><span class=o>-&gt;</span><span class=n>last_key</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>handle_encoding</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>r</span><span class=o>-&gt;</span><span class=n>pending_handle</span><span class=p>.</span><span class=n>EncodeTo</span><span class=p>(</span><span class=o>&amp;</span><span class=n>handle_encoding</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 写入最后构建的 data block 对应的 index block entry
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>r</span><span class=o>-&gt;</span><span class=n>index_block</span><span class=p>.</span><span class=n>Add</span><span class=p>(</span><span class=n>r</span><span class=o>-&gt;</span><span class=n>last_key</span><span class=p>,</span> <span class=n>Slice</span><span class=p>(</span><span class=n>handle_encoding</span><span class=p>));</span> 
</span></span><span class=line><span class=cl>    <span class=n>r</span><span class=o>-&gt;</span><span class=n>pending_index_entry</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=n>WriteBlock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>r</span><span class=o>-&gt;</span><span class=n>index_block</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>index_block_handle</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=216-写-footer class=headerLink><a href=#216-%e5%86%99-footer class=header-mark></a>2.1.6 写 footer</h4><p>footer 是 sstable 文件的入口, 结构比较简单:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// Footer 封装一个固定长度的信息, 它位于每个 table 文件的末尾. 
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>// 在每个 sstable 文件的末尾是一个固定长度的 footer, 
</span></span></span><span class=line><span class=cl><span class=c1>// 它包含了一个指向 metaindex block 的 BlockHandle
</span></span></span><span class=line><span class=cl><span class=c1>// 和一个指向 index block 的 BlockHandle 以及一个 magic number. 
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>Footer</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=n>Footer</span><span class=p>()</span> <span class=p>{</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=nf>EncodeTo</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>*</span> <span class=n>dst</span><span class=p>)</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>Status</span> <span class=nf>DecodeFrom</span><span class=p>(</span><span class=n>Slice</span><span class=o>*</span> <span class=n>input</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Footer 长度编码后的长度. 注意, 它就固定这么长. 
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// Footer 包含了一个 metaindex_handle、一个 index_handle、以及一个魔数. 
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>enum</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Footer 长度, 两个 BlockHandle 最大长度 + 固定的 8 字节魔数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>kEncodedLength</span> <span class=o>=</span> <span class=mi>2</span><span class=o>*</span><span class=n>BlockHandle</span><span class=o>::</span><span class=n>kMaxEncodedLength</span> <span class=o>+</span> <span class=mi>8</span>
</span></span><span class=line><span class=cl>  <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl> <span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=n>BlockHandle</span> <span class=n>metaindex_handle_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>BlockHandle</span> <span class=n>index_handle_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>其在 TableBuilder 的 Finish() 方法里完成写入:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// 5 最后将末尾的 Footer 写入 table 文件
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=p>(</span><span class=n>ok</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>Footer</span> <span class=n>footer</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>footer</span><span class=p>.</span><span class=n>set_metaindex_handle</span><span class=p>(</span><span class=n>metaindex_block_handle</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>footer</span><span class=p>.</span><span class=n>set_index_handle</span><span class=p>(</span><span class=n>index_block_handle</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>footer_encoding</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>footer</span><span class=p>.</span><span class=n>EncodeTo</span><span class=p>(</span><span class=o>&amp;</span><span class=n>footer_encoding</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>r</span><span class=o>-&gt;</span><span class=n>status</span> <span class=o>=</span> <span class=n>r</span><span class=o>-&gt;</span><span class=n>file</span><span class=o>-&gt;</span><span class=n>Append</span><span class=p>(</span><span class=n>footer_encoding</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>r</span><span class=o>-&gt;</span><span class=n>status</span><span class=p>.</span><span class=n>ok</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>r</span><span class=o>-&gt;</span><span class=n>offset</span> <span class=o>+=</span> <span class=n>footer_encoding</span><span class=p>.</span><span class=n>size</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=22-sstable-文件反序列化 class=headerLink><a href=#22-sstable-%e6%96%87%e4%bb%b6%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96 class=header-mark></a>2.2 sstable 文件反序列化</h3><p><code>class leveldb::Table</code> 可以看做是 sstable 文件的反序列化表示. 它负责对 sstable 进行反序列化并解析其内容, 该类是对 sstable 文件的抽象, 具体底层存储由 Table 的 helper 类 <code>struct leveldb::Table::Rep</code> 负责.</p><p>该类并不直接被客户代码调用, 用户调用 <code>DBImpl::Get()</code> 查询某个 key 的时候, 如果不在 memtable, 则会查询 sstable 文件, 此时会调用 <code>VersionSet::current_::Get()</code>, 并进而调用 <code>leveldb::TableCache::Get()</code> 查询被缓存的 Table 对象, 如果还没缓存文件对应的 Table 对象, 则会先读取然后将其加入缓存, 这里的读取操作就是 <code>Table::Open()</code> 方法提供的反序列化功能. 拿到 Table 对象后, 会调用其 <code>InternalGet()</code> 查询数据.</p><h4 id=221-总干事-table-类 class=headerLink><a href=#221-%e6%80%bb%e5%b9%b2%e4%ba%8b-table-%e7%b1%bb class=header-mark></a>2.2.1 总干事 Table 类</h4><p><code>Table</code> 是 sstable 文件反序列化后的内存形式, 包括 data blocks, data-index block, filter block 等, 核心成员如下:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// Table 是不可变且持久化的. 
</span></span></span><span class=line><span class=cl><span class=c1>// Table 可以被多个线程在不依赖外部同步设施的情况下安全地访问. 
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>LEVELDB_EXPORT</span> <span class=n>Table</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 打开一个保存在 file 中 [0..file_size) 里的
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 有序 table, 并读取必要的 metadata 数据项
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 以从该 table 检索数据. 
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 如果成功, 返回 OK 并将 *table 设置为新打开
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 的 table. 当不再使用该 table 时候, 客户端负责删除之. 
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 如果在初始化 table 出错, 将 *table 设置
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 为 nullptr 并返回 non-OK. 
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 而且, 在 table 打开期间, 客户端要确保数据源持续有效,
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 即当 table 在使用过程中, *file 必须保持有效. 
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>static</span> <span class=n>Status</span> <span class=n>Open</span><span class=p>(</span><span class=k>const</span> <span class=n>Options</span><span class=o>&amp;</span> <span class=n>options</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                     <span class=n>RandomAccessFile</span><span class=o>*</span> <span class=n>file</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                     <span class=kt>uint64_t</span> <span class=n>file_size</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                     <span class=n>Table</span><span class=o>**</span> <span class=n>table</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// 返回一个基于该 table 内容的迭代器. 
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 该方法返回的结果默认是无效的(在使用该迭代器之前, 
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 调用者在使用前必须调用其中一个 Seek 方法来
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 使迭代器生效.)
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>Iterator</span><span class=o>*</span> <span class=nf>NewIterator</span><span class=p>(</span><span class=k>const</span> <span class=n>ReadOptions</span><span class=o>&amp;</span><span class=p>)</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl> <span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=nc>Rep</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>Rep</span><span class=o>*</span> <span class=n>rep_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Seek(key) 找到某个数据项则会自动
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 调用 (*handle_result)(arg, ...);
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 如果过滤器明确表示不能做则不会调用.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>friend</span> <span class=k>class</span> <span class=nc>TableCache</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>Status</span> <span class=nf>InternalGet</span><span class=p>(</span>
</span></span><span class=line><span class=cl>      <span class=k>const</span> <span class=n>ReadOptions</span><span class=o>&amp;</span><span class=p>,</span> <span class=k>const</span> <span class=n>Slice</span><span class=o>&amp;</span> <span class=n>key</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=kt>void</span><span class=o>*</span> <span class=n>arg</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>handle_result</span><span class=p>)(</span><span class=kt>void</span><span class=o>*</span> <span class=n>arg</span><span class=p>,</span> <span class=k>const</span> <span class=n>Slice</span><span class=o>&amp;</span> <span class=n>k</span><span class=p>,</span> <span class=k>const</span> <span class=n>Slice</span><span class=o>&amp;</span> <span class=n>v</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=nf>ReadMeta</span><span class=p>(</span><span class=k>const</span> <span class=n>Footer</span><span class=o>&amp;</span> <span class=n>footer</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=nf>ReadFilter</span><span class=p>(</span><span class=k>const</span> <span class=n>Slice</span><span class=o>&amp;</span> <span class=n>filter_handle_value</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>读取 sstable 的入口为 <code>Table::Open()</code> 方法, 读取过程和 sstable 布局密切相关: 读 footer(这是文件入口), 读 data-index block, 再读 meta-index block 和 meta block. 没错, 该方法没有读取 data block.</p><p>该方法最后返回一个 <code>class leveldb::Table</code> 对象, 该对象会被调用方用作查询数据使用.</p><p>具体代码如下:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span><span class=lnt>70
</span><span class=lnt>71
</span><span class=lnt>72
</span><span class=lnt>73
</span><span class=lnt>74
</span><span class=lnt>75
</span><span class=lnt>76
</span><span class=lnt>77
</span><span class=lnt>78
</span><span class=lnt>79
</span><span class=lnt>80
</span><span class=lnt>81
</span><span class=lnt>82
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// 将 file 表示的 sstable 文件反序列化为 Table 对象, 具体保存
</span></span></span><span class=line><span class=cl><span class=c1>// 实际内容的是 Table::rep_.
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>// 如果成功, 返回 OK 并将 *table 设置为新打开的 table. 
</span></span></span><span class=line><span class=cl><span class=c1>// 当不再使用该 table 时候, 需要调用方负责删除之. 
</span></span></span><span class=line><span class=cl><span class=c1>// 如果初始化 table 出错, 将 *table 设置为 nullptr 并返回 non-OK. 
</span></span></span><span class=line><span class=cl><span class=c1>// 注意, 在 table 打开期间, 调用方要确保数据源即 file 持续有效. 
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Status</span> <span class=n>Table</span><span class=o>::</span><span class=n>Open</span><span class=p>(</span><span class=k>const</span> <span class=n>Options</span><span class=o>&amp;</span> <span class=n>options</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                   <span class=n>RandomAccessFile</span><span class=o>*</span> <span class=n>file</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                   <span class=kt>uint64_t</span> <span class=n>size</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                   <span class=n>Table</span><span class=o>**</span> <span class=n>table</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>   * 1 解析 footer: 它是 sstable 的入口.
</span></span></span><span class=line><span class=cl><span class=cm>   */</span>
</span></span><span class=line><span class=cl>  <span class=o>*</span><span class=n>table</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 每个 table 文件末尾是一个固定长度的 footer
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span> <span class=p>(</span><span class=n>size</span> <span class=o>&lt;</span> <span class=n>Footer</span><span class=o>::</span><span class=n>kEncodedLength</span><span class=p>)</span> <span class=p>{</span> 
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>Status</span><span class=o>::</span><span class=n>Corruption</span><span class=p>(</span><span class=s>&#34;file is too short to be an sstable&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kt>char</span> <span class=n>footer_space</span><span class=p>[</span><span class=n>Footer</span><span class=o>::</span><span class=n>kEncodedLength</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=n>Slice</span> <span class=n>footer_input</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 读取 footer, 放到 footer_input
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>Status</span> <span class=n>s</span> <span class=o>=</span> <span class=n>file</span><span class=o>-&gt;</span><span class=n>Read</span><span class=p>(</span><span class=n>size</span> <span class=o>-</span> <span class=n>Footer</span><span class=o>::</span><span class=n>kEncodedLength</span><span class=p>,</span> <span class=n>Footer</span><span class=o>::</span><span class=n>kEncodedLength</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                        <span class=o>&amp;</span><span class=n>footer_input</span><span class=p>,</span> <span class=n>footer_space</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>s</span><span class=p>.</span><span class=n>ok</span><span class=p>())</span> <span class=k>return</span> <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>Footer</span> <span class=n>footer</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 解析 footer
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>s</span> <span class=o>=</span> <span class=n>footer</span><span class=p>.</span><span class=n>DecodeFrom</span><span class=p>(</span><span class=o>&amp;</span><span class=n>footer_input</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>s</span><span class=p>.</span><span class=n>ok</span><span class=p>())</span> <span class=k>return</span> <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>   * 2 解析 data-index block:
</span></span></span><span class=line><span class=cl><span class=cm>   * 根据已解析的 Footer, 解析出 index block(它保存了指向全部 data blocks 的索引) 
</span></span></span><span class=line><span class=cl><span class=cm>   * 存储到 index_block_contents.
</span></span></span><span class=line><span class=cl><span class=cm>   */</span>
</span></span><span class=line><span class=cl>  <span class=n>BlockContents</span> <span class=n>index_block_contents</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>s</span><span class=p>.</span><span class=n>ok</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>ReadOptions</span> <span class=n>opt</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>options</span><span class=p>.</span><span class=n>paranoid_checks</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>opt</span><span class=p>.</span><span class=n>verify_checksums</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 读取 index block, 它对应的 BlockHandle 存储在 footer 里面
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>s</span> <span class=o>=</span> <span class=n>ReadBlock</span><span class=p>(</span><span class=n>file</span><span class=p>,</span> <span class=n>opt</span><span class=p>,</span> <span class=n>footer</span><span class=p>.</span><span class=n>index_handle</span><span class=p>(),</span> <span class=o>&amp;</span><span class=n>index_block_contents</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>s</span><span class=p>.</span><span class=n>ok</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 已经成功读取了 Footer 和 index block, 是时候读取 data 了. 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Block</span><span class=o>*</span> <span class=n>index_block</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Block</span><span class=p>(</span><span class=n>index_block_contents</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>Rep</span><span class=o>*</span> <span class=n>rep</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Table</span><span class=o>::</span><span class=n>Rep</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>rep</span><span class=o>-&gt;</span><span class=n>options</span> <span class=o>=</span> <span class=n>options</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>rep</span><span class=o>-&gt;</span><span class=n>file</span> <span class=o>=</span> <span class=n>file</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// filter-index block 对应的指针 (二级索引), 解析 footer 时候就拿到了.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>rep</span><span class=o>-&gt;</span><span class=n>metaindex_handle</span> <span class=o>=</span> <span class=n>footer</span><span class=p>.</span><span class=n>metaindex_handle</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=c1>// data-index block 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// (注意它只是一个索引, 即 data blocks 的索引, 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//  真正使用的时候是基于 data-index block 做二级迭代器来进行查询,
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//  一级索引跨度大, 二级索引粒度小, 可以快速定位数据,
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//  具体见 Table::NewIterator() 方法)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>rep</span><span class=o>-&gt;</span><span class=n>index_block</span> <span class=o>=</span> <span class=n>index_block</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 如果调用方要求缓存这个 table, 则为其分配缓存 id
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>rep</span><span class=o>-&gt;</span><span class=n>cache_id</span> <span class=o>=</span> <span class=p>(</span><span class=n>options</span><span class=p>.</span><span class=n>block_cache</span> <span class=o>?</span> <span class=n>options</span><span class=p>.</span><span class=n>block_cache</span><span class=o>-&gt;</span><span class=n>NewId</span><span class=p>()</span> <span class=o>:</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 接下来跟 filter 相关的两个成员将在下面 ReadMeta 进行填充.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>rep</span><span class=o>-&gt;</span><span class=n>filter_data</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>rep</span><span class=o>-&gt;</span><span class=n>filter</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=n>table</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Table</span><span class=p>(</span><span class=n>rep</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>     * 3 解析 meta-index block 和 meta block:
</span></span></span><span class=line><span class=cl><span class=cm>     * 根据已解析的 Footer 所包含的 metaindex block 指针, 
</span></span></span><span class=line><span class=cl><span class=cm>     * 解析出 metaindex block, 再基于此解析出 mate block 
</span></span></span><span class=line><span class=cl><span class=cm>     * 存储到 Table::rep_.
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 读取并解析 filter block 到 table::rep_, 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 它一般为布隆过滤器, 可以加速数据查询过程.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>(</span><span class=o>*</span><span class=n>table</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>ReadMeta</span><span class=p>(</span><span class=n>footer</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// 是的, 该方法没有解析 data blocks.
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>总结下, 该方法主要干了下面三件事:</p><ol><li>先解析 sstable 文件结尾的 Footer, 它是 sstable 的入口.</li><li>根据已解析的 Footer, 解析出 (data) index block 存储到 Table::rep_.</li><li>根据已解析的 Footer, 解析出 meta block 存储到 Table::rep_.</li></ol><p>注意, <code>Open</code> 方法并未去解析 data block 部分, 仅仅是解析了它对应的 index block 部分 和 meta block(它包含的是过滤器, 用来快速确认 key 是否存在).</p><p>那什么时候才解析 data block 呢? 答案是调用 <code>InternalGet()</code> 时候:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// 在 table 中查找 k 对应的数据项. 
</span></span></span><span class=line><span class=cl><span class=c1>// 如果 table 具有 filter, 则用 filter 找; 
</span></span></span><span class=line><span class=cl><span class=c1>// 如果没有 filter 则去 data block 里面查找, 
</span></span></span><span class=line><span class=cl><span class=c1>// 并且在找到后通过 saver 保存 key/value. 
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Status</span> <span class=n>Table</span><span class=o>::</span><span class=n>InternalGet</span><span class=p>(</span><span class=k>const</span> <span class=n>ReadOptions</span><span class=o>&amp;</span> <span class=n>options</span><span class=p>,</span> <span class=k>const</span> <span class=n>Slice</span><span class=o>&amp;</span> <span class=n>k</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                          <span class=kt>void</span><span class=o>*</span> <span class=n>arg</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                          <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>saver</span><span class=p>)(</span><span class=kt>void</span><span class=o>*</span><span class=p>,</span> <span class=k>const</span> <span class=n>Slice</span><span class=o>&amp;</span><span class=p>,</span> <span class=k>const</span> <span class=n>Slice</span><span class=o>&amp;</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>Status</span> <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 针对 data index block 构造 iterator
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>Iterator</span><span class=o>*</span> <span class=n>iiter</span> <span class=o>=</span> <span class=n>rep_</span><span class=o>-&gt;</span><span class=n>index_block</span><span class=o>-&gt;</span><span class=n>NewIterator</span><span class=p>(</span><span class=n>rep_</span><span class=o>-&gt;</span><span class=n>options</span><span class=p>.</span><span class=n>comparator</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 在 data index block 中寻找第一个大于等于 k 的数据项, 这个数据项
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 就是目标 data block 的 handle.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>iiter</span><span class=o>-&gt;</span><span class=n>Seek</span><span class=p>(</span><span class=n>k</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>iiter</span><span class=o>-&gt;</span><span class=n>Valid</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 取出对应的 data block 的 BlockHandle
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Slice</span> <span class=n>handle_value</span> <span class=o>=</span> <span class=n>iiter</span><span class=o>-&gt;</span><span class=n>value</span><span class=p>();</span> 
</span></span><span class=line><span class=cl>    <span class=n>FilterBlockReader</span><span class=o>*</span> <span class=n>filter</span> <span class=o>=</span> <span class=n>rep_</span><span class=o>-&gt;</span><span class=n>filter</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>BlockHandle</span> <span class=n>handle</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 如果有 filter 找起来就快了, 如果确定
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 不存在就可以直接反悔了.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>filter</span> <span class=o>!=</span> <span class=k>nullptr</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl>        <span class=n>handle</span><span class=p>.</span><span class=n>DecodeFrom</span><span class=p>(</span><span class=o>&amp;</span><span class=n>handle_value</span><span class=p>).</span><span class=n>ok</span><span class=p>()</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl>        <span class=o>!</span><span class=n>filter</span><span class=o>-&gt;</span><span class=n>KeyMayMatch</span><span class=p>(</span><span class=n>handle</span><span class=p>.</span><span class=n>offset</span><span class=p>(),</span> <span class=n>k</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=c1>// 没在该 data block 对应的过滤器找到这个 key, 肯定不存在
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span> 
</span></span><span class=line><span class=cl>      <span class=c1>// 如果没有 filter, 或者在 filter 中查询时无法笃定
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=c1>// key 不存在, 就需要在 block 中进行查找.
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=c1>// 看到了没? Open() 方法没有解析任何 data block, 解析
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=c1>// 是在这里进行的, 因为这里要查询数据了.
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=n>Iterator</span><span class=o>*</span> <span class=n>block_iter</span> <span class=o>=</span> <span class=n>BlockReader</span><span class=p>(</span><span class=k>this</span><span class=p>,</span> <span class=n>options</span><span class=p>,</span> <span class=n>iiter</span><span class=o>-&gt;</span><span class=n>value</span><span class=p>());</span>
</span></span><span class=line><span class=cl>      <span class=n>block_iter</span><span class=o>-&gt;</span><span class=n>Seek</span><span class=p>(</span><span class=n>k</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=n>block_iter</span><span class=o>-&gt;</span><span class=n>Valid</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 将找到的 key/value 保存到输出型参数 arg 中, 
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// 因为后面会将迭代器释放掉.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>(</span><span class=o>*</span><span class=n>saver</span><span class=p>)(</span><span class=n>arg</span><span class=p>,</span> <span class=n>block_iter</span><span class=o>-&gt;</span><span class=n>key</span><span class=p>(),</span> <span class=n>block_iter</span><span class=o>-&gt;</span><span class=n>value</span><span class=p>());</span> 
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=n>s</span> <span class=o>=</span> <span class=n>block_iter</span><span class=o>-&gt;</span><span class=n>status</span><span class=p>();</span>
</span></span><span class=line><span class=cl>      <span class=k>delete</span> <span class=n>block_iter</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>s</span><span class=p>.</span><span class=n>ok</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>s</span> <span class=o>=</span> <span class=n>iiter</span><span class=o>-&gt;</span><span class=n>status</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>delete</span> <span class=n>iiter</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><code>Open()</code> 方法会读取 block 构造 Block 然后放到 <code>Table::Rep</code> 中, 解析过程也用到了 <code>Block</code> 类. 在分别介绍各个组成部分读取解析之前先说一下这两个类.</p><h5 id=2211-table-类的小助手之一-rep class=headerLink><a href=#2211-table-%e7%b1%bb%e7%9a%84%e5%b0%8f%e5%8a%a9%e6%89%8b%e4%b9%8b%e4%b8%80-rep class=header-mark></a>2.2.1.1 Table 类的小助手之一 Rep</h5><p>该类负责存储 sstable 反序列化后的各个部分内容:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// 存储 table 中各个元素的结构
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=nc>Table</span><span class=o>::</span><span class=n>Rep</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=o>~</span><span class=n>Rep</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>delete</span> <span class=n>filter</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>delete</span> <span class=p>[]</span> <span class=n>filter_data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>delete</span> <span class=n>index_block</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// 控制 Table 的一些选项, 比如是否进行缓存等.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>Options</span> <span class=n>options</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>Status</span> <span class=n>status</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=c1>// table 对应的 sstable 文件
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>RandomAccessFile</span><span class=o>*</span> <span class=n>file</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>  <span class=c1>// 如果该 table 具备对应的 block_cache, 
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 该值与 block 在 table 中的起始偏移量一起构成 key, value 为 block
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>uint64_t</span> <span class=n>cache_id</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>  <span class=c1>// 解析出来的 filter block
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>FilterBlockReader</span><span class=o>*</span> <span class=n>filter</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>  <span class=c1>// filter block 原始数据
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>filter_data</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// 从 table Footer 取出来的, 指向 table 的 metaindex block
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>BlockHandle</span> <span class=n>metaindex_handle</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=c1>// index block 原始数据, 保存的是每个 data block 的 BlockHandle
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>Block</span><span class=o>*</span> <span class=n>index_block</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><h5 id=2212-table-类的小助手之二-block class=headerLink><a href=#2212-table-%e7%b1%bb%e7%9a%84%e5%b0%8f%e5%8a%a9%e6%89%8b%e4%b9%8b%e4%ba%8c-block class=header-mark></a>2.2.1.2 Table 类的小助手之二 Block</h5><p><code>class leveldb::Block</code> 定义在 <code>table/block.h</code> 和 <code>table/block.cc</code> 文件, sstable 中的每个 block 都会被反序列化为一个 <code>Block</code> 对象. 具体类定义如下:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>Block</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 使用特定的 contents 来构造一个 Block
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>explicit</span> <span class=n>Block</span><span class=p>(</span><span class=k>const</span> <span class=n>BlockContents</span><span class=o>&amp;</span> <span class=n>contents</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=o>~</span><span class=n>Block</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>size_t</span> <span class=nf>size</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=n>size_</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 根据用户定制的 comparator 构造该 block 的一个迭代器
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>Iterator</span><span class=o>*</span> <span class=nf>NewIterator</span><span class=p>(</span><span class=k>const</span> <span class=n>Comparator</span><span class=o>*</span> <span class=n>comparator</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl> <span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=kt>uint32_t</span> <span class=n>NumRestarts</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// block 全部数据(数据项 + restart array + restart number)
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>data_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=c1>// block 总大小 
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>size_t</span> <span class=n>size_</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>  <span class=c1>// block 的 restart array 在 block 中的起始偏移量
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>uint32_t</span> <span class=n>restart_offset_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 如果 data_ 指向的空间是在堆上分配的, 
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 那么该 block 对象销毁时需要释放该处空间, 该成员使用见析构方法.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>bool</span> <span class=n>owned_</span><span class=p>;</span>                  
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// 不允许拷贝 block 
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>Block</span><span class=p>(</span><span class=k>const</span> <span class=n>Block</span><span class=o>&amp;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>Block</span><span class=o>&amp;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// 为迭代 block 内容服务的迭代器, block 相当于迭代器的数据源.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>class</span> <span class=nc>Iter</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>构造 <code>Block</code> 对象只有一种方式, 就是先读取文件内容构造 <code>BlockContents</code>, 然后基于 <code>BlockContents</code> 构造 <code>Block</code>, 这个在 <code>Table::Open()</code> 中解析 data-index block 和 meta-index block 时多次用到.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>Block</span><span class=o>::</span><span class=n>Block</span><span class=p>(</span><span class=k>const</span> <span class=n>BlockContents</span><span class=o>&amp;</span> <span class=n>contents</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=o>:</span> <span class=n>data_</span><span class=p>(</span><span class=n>contents</span><span class=p>.</span><span class=n>data</span><span class=p>.</span><span class=n>data</span><span class=p>()),</span>
</span></span><span class=line><span class=cl>      <span class=n>size_</span><span class=p>(</span><span class=n>contents</span><span class=p>.</span><span class=n>data</span><span class=p>.</span><span class=n>size</span><span class=p>()),</span>
</span></span><span class=line><span class=cl>      <span class=n>owned_</span><span class=p>(</span><span class=n>contents</span><span class=p>.</span><span class=n>heap_allocated</span><span class=p>)</span> <span class=p>{</span> 
</span></span><span class=line><span class=cl>  <span class=c1>//　当数据存储在堆上的时候 owned_ 才为 true
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span> <span class=p>(</span><span class=n>size_</span> <span class=o>&lt;</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>uint32_t</span><span class=p>))</span> <span class=p>{</span> 
</span></span><span class=line><span class=cl>    <span class=c1>// block 最后 4 字节用于存储 restart 个数, 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 所以 block 长度最小为 4 字节长度.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>size_</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>  <span class=c1>// Error marker
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 该 Block 最多可以分配的 restart 的个数, 其中每个 restart 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 为 4 字节偏移量.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 在构建 block 的时候会每隔一段设置一个 restart point(用于前缀压缩), 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 位于 restart point 的数据项的 key 保留原样, 此项之后
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 的数据项会相对于前一个数据项进行前缀压缩直至下一个 restart  point. 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// block 最后 4 字节用于存储 restart 个数, 所以计算时不能算在内. 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>size_t</span> <span class=n>max_restarts_allowed</span> <span class=o>=</span> <span class=p>(</span><span class=n>size_</span><span class=o>-</span><span class=k>sizeof</span><span class=p>(</span><span class=kt>uint32_t</span><span class=p>))</span> <span class=o>/</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>uint32_t</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>NumRestarts</span><span class=p>()</span> <span class=o>&gt;</span> <span class=n>max_restarts_allowed</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=c1>// 如果实际的 restart 总数超过了上面计算的最大值, 
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=c1>// 那该 Block 空间太小了, 肯定有问题
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=n>size_</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=c1>// 最后一个 uint_32 存的是 restart 个数, 不能用于存放 restart; 
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=c1>// 全部 restart 占用字节数为 NumRestarts() * sizeof(uint32_t); 
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=c1>// 所以 restart array 的起始 offset 为下面的值. 
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=n>restart_offset_</span> <span class=o>=</span> <span class=n>size_</span> <span class=o>-</span> <span class=p>(</span><span class=mi>1</span> <span class=o>+</span> <span class=n>NumRestarts</span><span class=p>())</span> <span class=o>*</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>uint32_t</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=222-读-footer class=headerLink><a href=#222-%e8%af%bb-footer class=header-mark></a>2.2.2 读 footer</h4><p>footer 解析比较简单, 主要就是获取 meta-index block 和 data-index block 分别在文件中的地址和大小:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// 从 input 指向内存解码出一个 Footer, 
</span></span></span><span class=line><span class=cl><span class=c1>// 先解码最后 8 字节的魔数(按照小端模式), 
</span></span></span><span class=line><span class=cl><span class=c1>// 然后一次解码两个 BlockHandle. 
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Status</span> <span class=n>Footer</span><span class=o>::</span><span class=n>DecodeFrom</span><span class=p>(</span><span class=n>Slice</span><span class=o>*</span> <span class=n>input</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 1 按照小端模式解析末尾 8 字节的魔数
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>magic_ptr</span> <span class=o>=</span> <span class=n>input</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>()</span> <span class=o>+</span> <span class=n>kEncodedLength</span> <span class=o>-</span> <span class=mi>8</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=kt>uint32_t</span> <span class=n>magic_lo</span> <span class=o>=</span> <span class=n>DecodeFixed32</span><span class=p>(</span><span class=n>magic_ptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=kt>uint32_t</span> <span class=n>magic_hi</span> <span class=o>=</span> <span class=n>DecodeFixed32</span><span class=p>(</span><span class=n>magic_ptr</span> <span class=o>+</span> <span class=mi>4</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=kt>uint64_t</span> <span class=n>magic</span> <span class=o>=</span> <span class=p>((</span><span class=k>static_cast</span><span class=o>&lt;</span><span class=kt>uint64_t</span><span class=o>&gt;</span><span class=p>(</span><span class=n>magic_hi</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=mi>32</span><span class=p>)</span> <span class=o>|</span>
</span></span><span class=line><span class=cl>                          <span class=p>(</span><span class=k>static_cast</span><span class=o>&lt;</span><span class=kt>uint64_t</span><span class=o>&gt;</span><span class=p>(</span><span class=n>magic_lo</span><span class=p>)));</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>magic</span> <span class=o>!=</span> <span class=n>kTableMagicNumber</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>Status</span><span class=o>::</span><span class=n>Corruption</span><span class=p>(</span><span class=s>&#34;not an sstable (bad magic number)&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// 2 解析 meta-index block 的 handle
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// (包含 meta index block 起始偏移量及其长度)
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>Status</span> <span class=n>result</span> <span class=o>=</span> <span class=n>metaindex_handle_</span><span class=p>.</span><span class=n>DecodeFrom</span><span class=p>(</span><span class=n>input</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>result</span><span class=p>.</span><span class=n>ok</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 3 解析 index block 的 handle
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// (包含 index block 起始偏移量及其长度)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>result</span> <span class=o>=</span> <span class=n>index_handle_</span><span class=p>.</span><span class=n>DecodeFrom</span><span class=p>(</span><span class=n>input</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>result</span><span class=p>.</span><span class=n>ok</span><span class=p>())</span> <span class=p>{</span> 
</span></span><span class=line><span class=cl>    <span class=c1>// 4 跳过 padding
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// meta-index handle + data-index handle + padding + 魔数.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 此时 input 包含的数据只剩下可能的 padding 0 了, 跳过.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// end 为 footer 尾部
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>end</span> <span class=o>=</span> <span class=n>magic_ptr</span> <span class=o>+</span> <span class=mi>8</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 第二个参数为值为 0. 生成下面这个 slice 后面没有使用. 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>*</span><span class=n>input</span> <span class=o>=</span> <span class=n>Slice</span><span class=p>(</span><span class=n>end</span><span class=p>,</span> <span class=n>input</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>()</span> <span class=o>+</span> <span class=n>input</span><span class=o>-&gt;</span><span class=n>size</span><span class=p>()</span> <span class=o>-</span> <span class=n>end</span><span class=p>);</span> 
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>result</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=223-读-data-index-block class=headerLink><a href=#223-%e8%af%bb-data-index-block class=header-mark></a>2.2.3 读 data-index block</h4><p>拿到 data-index block 地址和大小后就可以解析它了:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>  * 2 解析 data-index block:
</span></span></span><span class=line><span class=cl><span class=cm>  * 根据已解析的 Footer, 解析出 index block(它保存了指向全部 data blocks 的索引) 
</span></span></span><span class=line><span class=cl><span class=cm>  * 存储到 index_block_contents.
</span></span></span><span class=line><span class=cl><span class=cm>  */</span>
</span></span><span class=line><span class=cl><span class=n>BlockContents</span> <span class=n>index_block_contents</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>s</span><span class=p>.</span><span class=n>ok</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>ReadOptions</span> <span class=n>opt</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>options</span><span class=p>.</span><span class=n>paranoid_checks</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>opt</span><span class=p>.</span><span class=n>verify_checksums</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 读取 index block, 它对应的 BlockHandle 存储在 footer 里面
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>s</span> <span class=o>=</span> <span class=n>ReadBlock</span><span class=p>(</span><span class=n>file</span><span class=p>,</span> <span class=n>opt</span><span class=p>,</span> <span class=n>footer</span><span class=p>.</span><span class=n>index_handle</span><span class=p>(),</span> <span class=o>&amp;</span><span class=n>index_block_contents</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>上面 <code>ReadBlock()</code> 最后一个输出型参数即为 data-index block 内容, 可以将其反序列化为 <code>Block</code> 对象:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>Block</span><span class=o>*</span> <span class=n>index_block</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Block</span><span class=p>(</span><span class=n>index_block_contents</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=224-读-meta-index-block class=headerLink><a href=#224-%e8%af%bb-meta-index-block class=header-mark></a>2.2.4 读 meta-index block</h4><p>解析出来的 meta-index block handle 放到了 footer 对象中, 根据它就可以解析 meta-index block 和 meta block 了:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>  * 3 解析 meta-index block 和 meta block:
</span></span></span><span class=line><span class=cl><span class=cm>  * 根据已解析的 Footer 所包含的 metaindex block 指针, 
</span></span></span><span class=line><span class=cl><span class=cm>  * 解析出 metaindex block, 再基于此解析出 mate block 
</span></span></span><span class=line><span class=cl><span class=cm>  * 存储到 Table::rep_.
</span></span></span><span class=line><span class=cl><span class=cm>  */</span>
</span></span><span class=line><span class=cl><span class=c1>// 读取并解析 filter block 到 table::rep_, 
</span></span></span><span class=line><span class=cl><span class=c1>// 它一般为布隆过滤器, 可以加速数据查询过程.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>(</span><span class=o>*</span><span class=n>table</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>ReadMeta</span><span class=p>(</span><span class=n>footer</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><p>这个过程统一在 <code>ReadMeta()</code> 完成, 具体读取 meta block 会有专用的 <code>ReadFilter()</code> 完成:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// 解析 table 的 metaindex block(需要先解析 table 的 footer);
</span></span></span><span class=line><span class=cl><span class=c1>// 然后根据解析出来的 metaindex block 解析 meta block(目前 meta block
</span></span></span><span class=line><span class=cl><span class=c1>// 仅有 filter block 一种). 
</span></span></span><span class=line><span class=cl><span class=c1>// 这就是我们要的元数据, 解析出来的元数据会被放到 Table::rep_ 中. 
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=n>Table</span><span class=o>::</span><span class=n>ReadMeta</span><span class=p>(</span><span class=k>const</span> <span class=n>Footer</span><span class=o>&amp;</span> <span class=n>footer</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 如果压根就没配置过滤策略, 那么无序解析元数据
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span> <span class=p>(</span><span class=n>rep_</span><span class=o>-&gt;</span><span class=n>options</span><span class=p>.</span><span class=n>filter_policy</span> <span class=o>==</span> <span class=k>nullptr</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>   * 根据 Footer 保存的 metaindex BlockHandle 
</span></span></span><span class=line><span class=cl><span class=cm>   * 解析对应的 metaindex block 到 meta 中
</span></span></span><span class=line><span class=cl><span class=cm>   */</span>
</span></span><span class=line><span class=cl>  <span class=n>ReadOptions</span> <span class=n>opt</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>rep_</span><span class=o>-&gt;</span><span class=n>options</span><span class=p>.</span><span class=n>paranoid_checks</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 如果开启了偏执检查, 则校验每个 block 的 crc
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>opt</span><span class=p>.</span><span class=n>verify_checksums</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=n>BlockContents</span> <span class=n>contents</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 1 根据 handle 读取 metaindex block (从 rep_ 到 contents)
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>ReadBlock</span><span class=p>(</span><span class=n>rep_</span><span class=o>-&gt;</span><span class=n>file</span><span class=p>,</span> <span class=n>opt</span><span class=p>,</span> <span class=n>footer</span><span class=p>.</span><span class=n>metaindex_handle</span><span class=p>(),</span> <span class=o>&amp;</span><span class=n>contents</span><span class=p>).</span><span class=n>ok</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 由于 filter block 不是必须的, 没有 filter 最多就是读得慢一些;
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 所以出错也不再继续传播, 而是直接返回.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// 这个变量叫 metaindex 更合适
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>Block</span><span class=o>*</span> <span class=n>meta</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Block</span><span class=p>(</span><span class=n>contents</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// 为 metaindex block 创建一个迭代器
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>Iterator</span><span class=o>*</span> <span class=n>iter</span> <span class=o>=</span> <span class=n>meta</span><span class=o>-&gt;</span><span class=n>NewIterator</span><span class=p>(</span><span class=n>BytewiseComparator</span><span class=p>());</span> 
</span></span><span class=line><span class=cl>  <span class=c1>// 具体见 table_format.md
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// metaindex block 有一个 entry 包含了 FilterPolicy name 
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 到其对应的 filter block 的映射
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>key</span> <span class=o>=</span> <span class=s>&#34;filter.&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=c1>// filter-policy name 在调用方传进来的配置项中
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>key</span><span class=p>.</span><span class=n>append</span><span class=p>(</span><span class=n>rep_</span><span class=o>-&gt;</span><span class=n>options</span><span class=p>.</span><span class=n>filter_policy</span><span class=o>-&gt;</span><span class=n>Name</span><span class=p>());</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 在 metaindex block 搜寻 key 对应的 meta block 的 handle
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>iter</span><span class=o>-&gt;</span><span class=n>Seek</span><span class=p>(</span><span class=n>key</span><span class=p>);</span> 
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>iter</span><span class=o>-&gt;</span><span class=n>Valid</span><span class=p>()</span> <span class=o>&amp;&amp;</span> <span class=n>iter</span><span class=o>-&gt;</span><span class=n>key</span><span class=p>()</span> <span class=o>==</span> <span class=n>Slice</span><span class=p>(</span><span class=n>key</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 2 找到了, 迭代器对应的 value 即为 meta block handle,
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 根据其解析对应的 filter block(就是 meta block), 解析出来的
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 内容会放到 rep_ 中.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>ReadFilter</span><span class=p>(</span><span class=n>iter</span><span class=o>-&gt;</span><span class=n>value</span><span class=p>());</span> 
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>delete</span> <span class=n>iter</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>delete</span> <span class=n>meta</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=225-读-meta-block class=headerLink><a href=#225-%e8%af%bb-meta-block class=header-mark></a>2.2.5 读 meta block</h4><p>前一节提到了读取 meta(filter) block 读取:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// 2 找到了, 则解析对应的 filter block, 解析出来的
</span></span></span><span class=line><span class=cl><span class=c1>// 内容会放到 rep_ 中.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>ReadFilter</span><span class=p>(</span><span class=n>iter</span><span class=o>-&gt;</span><span class=n>value</span><span class=p>());</span> 
</span></span></code></pre></td></tr></table></div></div><p>具体读取由 <code>ReadFilter()</code> 方法完成:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// 解析 table 的 filter block(需要先解析 table 的 metaindex block)
</span></span></span><span class=line><span class=cl><span class=c1>// 解析出的数据放到了 table.rep.filter
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=n>Table</span><span class=o>::</span><span class=n>ReadFilter</span><span class=p>(</span><span class=k>const</span> <span class=n>Slice</span><span class=o>&amp;</span> <span class=n>filter_handle_value</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>Slice</span> <span class=n>v</span> <span class=o>=</span> <span class=n>filter_handle_value</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>BlockHandle</span> <span class=n>filter_handle</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 解析出 filter block 对应的 blockhandle, 它包含 filter block 
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 在 sstable 中的偏移量和大小
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>filter_handle</span><span class=p>.</span><span class=n>DecodeFrom</span><span class=p>(</span><span class=o>&amp;</span><span class=n>v</span><span class=p>).</span><span class=n>ok</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>ReadOptions</span> <span class=n>opt</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>rep_</span><span class=o>-&gt;</span><span class=n>options</span><span class=p>.</span><span class=n>paranoid_checks</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>opt</span><span class=p>.</span><span class=n>verify_checksums</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=n>BlockContents</span> <span class=n>block</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 读取 filter block(从 rep_ 到 block)
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>ReadBlock</span><span class=p>(</span><span class=n>rep_</span><span class=o>-&gt;</span><span class=n>file</span><span class=p>,</span> <span class=n>opt</span><span class=p>,</span> <span class=n>filter_handle</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>block</span><span class=p>).</span><span class=n>ok</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// 如果 blockcontents 中的内存是从堆分配的, 
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 需要将其地址赋值给 rep_-&gt;filter_data 以方便后续释放(见 ~Rep())
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span> <span class=p>(</span><span class=n>block</span><span class=p>.</span><span class=n>heap_allocated</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>rep_</span><span class=o>-&gt;</span><span class=n>filter_data</span> <span class=o>=</span> <span class=n>block</span><span class=p>.</span><span class=n>data</span><span class=p>.</span><span class=n>data</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 反序列化 filter block (从 block.data 到 FilterBlockReader)
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>rep_</span><span class=o>-&gt;</span><span class=n>filter</span> <span class=o>=</span> <span class=k>new</span> <span class=n>FilterBlockReader</span><span class=p>(</span><span class=n>rep_</span><span class=o>-&gt;</span><span class=n>options</span><span class=p>.</span><span class=n>filter_policy</span><span class=p>,</span> <span class=n>block</span><span class=p>.</span><span class=n>data</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=226-读-block-内容的通用方法 class=headerLink><a href=#226-%e8%af%bb-block-%e5%86%85%e5%ae%b9%e7%9a%84%e9%80%9a%e7%94%a8%e6%96%b9%e6%b3%95 class=header-mark></a>2.2.6 读 block 内容的通用方法</h4><p>每个 block(data block, meta block, meta-index block, data-index block 四类) 在写入 sstable 后都会紧接着追加一字节长的压缩类型和四字节长的 crc(它是 block + 压缩类型一起算出来的), 负责读取解析 block + 压缩类型 + crc 的方法为位于 <code>table/format.cc</code> 中的 <code>ReadBlock()</code> 方法:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span><span class=lnt>70
</span><span class=lnt>71
</span><span class=lnt>72
</span><span class=lnt>73
</span><span class=lnt>74
</span><span class=lnt>75
</span><span class=lnt>76
</span><span class=lnt>77
</span><span class=lnt>78
</span><span class=lnt>79
</span><span class=lnt>80
</span><span class=lnt>81
</span><span class=lnt>82
</span><span class=lnt>83
</span><span class=lnt>84
</span><span class=lnt>85
</span><span class=lnt>86
</span><span class=lnt>87
</span><span class=lnt>88
</span><span class=lnt>89
</span><span class=lnt>90
</span><span class=lnt>91
</span><span class=lnt>92
</span><span class=lnt>93
</span><span class=lnt>94
</span><span class=lnt>95
</span><span class=lnt>96
</span><span class=lnt>97
</span><span class=lnt>98
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// 从 file 去读 handle 指向的 block:
</span></span></span><span class=line><span class=cl><span class=c1>// - 读取整个块, 包含数据+压缩类型(1 字节)+crc(4 字节)
</span></span></span><span class=line><span class=cl><span class=c1>// - 校验 crc: 重新计算 crc 并与保存 crc 比较
</span></span></span><span class=line><span class=cl><span class=c1>// - 解析压缩类型, 根据压缩类型对数据进行解压缩
</span></span></span><span class=line><span class=cl><span class=c1>// - 将 block 数据部分保存到 BlockContents 中
</span></span></span><span class=line><span class=cl><span class=c1>// 失败返回 non-OK; 成功则将数据填充到 *result 并返回 OK. 
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Status</span> <span class=nf>ReadBlock</span><span class=p>(</span><span class=n>RandomAccessFile</span><span class=o>*</span> <span class=n>file</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                 <span class=k>const</span> <span class=n>ReadOptions</span><span class=o>&amp;</span> <span class=n>options</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                 <span class=k>const</span> <span class=n>BlockHandle</span><span class=o>&amp;</span> <span class=n>handle</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                 <span class=n>BlockContents</span><span class=o>*</span> <span class=n>result</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>result</span><span class=o>-&gt;</span><span class=n>data</span> <span class=o>=</span> <span class=n>Slice</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=n>result</span><span class=o>-&gt;</span><span class=n>cachable</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>result</span><span class=o>-&gt;</span><span class=n>heap_allocated</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>   * 解析 block.
</span></span></span><span class=line><span class=cl><span class=cm>   * 读取 block 内容以及 type 和 crc. 
</span></span></span><span class=line><span class=cl><span class=cm>   * 具体见 table_builder.cc 中构造这个结构的代码.
</span></span></span><span class=line><span class=cl><span class=cm>   */</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 要读取的 block 的大小
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>size_t</span> <span class=n>n</span> <span class=o>=</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=n>size_t</span><span class=o>&gt;</span><span class=p>(</span><span class=n>handle</span><span class=p>.</span><span class=n>size</span><span class=p>());</span> 
</span></span><span class=line><span class=cl>  <span class=c1>// 每个 block 后面紧跟着它的压缩类型 type (1 字节)和 crc (4 字节)
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>char</span><span class=o>*</span> <span class=n>buf</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>char</span><span class=p>[</span><span class=n>n</span> <span class=o>+</span> <span class=n>kBlockTrailerSize</span><span class=p>];</span> 
</span></span><span class=line><span class=cl>  <span class=n>Slice</span> <span class=n>contents</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=c1>// handle.offset() 指向对应 block 在文件里的起始偏移量
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>Status</span> <span class=n>s</span> <span class=o>=</span> <span class=n>file</span><span class=o>-&gt;</span><span class=n>Read</span><span class=p>(</span><span class=n>handle</span><span class=p>.</span><span class=n>offset</span><span class=p>(),</span> <span class=n>n</span> <span class=o>+</span> <span class=n>kBlockTrailerSize</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>contents</span><span class=p>,</span> <span class=n>buf</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>s</span><span class=p>.</span><span class=n>ok</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>delete</span><span class=p>[]</span> <span class=n>buf</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>contents</span><span class=p>.</span><span class=n>size</span><span class=p>()</span> <span class=o>!=</span> <span class=n>n</span> <span class=o>+</span> <span class=n>kBlockTrailerSize</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>delete</span><span class=p>[]</span> <span class=n>buf</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>Status</span><span class=o>::</span><span class=n>Corruption</span><span class=p>(</span><span class=s>&#34;truncated block read&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>   * 校验 type 和 block 内容加在一起对应的 crc
</span></span></span><span class=line><span class=cl><span class=cm>   */</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>data</span> <span class=o>=</span> <span class=n>contents</span><span class=p>.</span><span class=n>data</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>options</span><span class=p>.</span><span class=n>verify_checksums</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 读取 block 末尾的 crc(始于第 n+1 字节)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>const</span> <span class=kt>uint32_t</span> <span class=n>crc</span> <span class=o>=</span> <span class=n>crc32c</span><span class=o>::</span><span class=n>Unmask</span><span class=p>(</span><span class=n>DecodeFixed32</span><span class=p>(</span><span class=n>data</span> <span class=o>+</span> <span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 计算 block 前 n+1 字节的 crc
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>const</span> <span class=kt>uint32_t</span> <span class=n>actual</span> <span class=o>=</span> <span class=n>crc32c</span><span class=o>::</span><span class=n>Value</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 比较保存的 crc 和实际计算的 crc 是否一致
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>actual</span> <span class=o>!=</span> <span class=n>crc</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>delete</span><span class=p>[]</span> <span class=n>buf</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=n>s</span> <span class=o>=</span> <span class=n>Status</span><span class=o>::</span><span class=n>Corruption</span><span class=p>(</span><span class=s>&#34;block checksum mismatch&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>   * 解析 type, 并根据 type 解析 block data
</span></span></span><span class=line><span class=cl><span class=cm>   */</span>
</span></span><span class=line><span class=cl>  <span class=c1>// type 表示 block 的压缩状态
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>switch</span> <span class=p>(</span><span class=n>data</span><span class=p>[</span><span class=n>n</span><span class=p>])</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=nl>kNoCompression</span><span class=p>:</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=n>data</span> <span class=o>!=</span> <span class=n>buf</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>delete</span><span class=p>[]</span> <span class=n>buf</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>result</span><span class=o>-&gt;</span><span class=n>data</span> <span class=o>=</span> <span class=n>Slice</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=n>n</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>result</span><span class=o>-&gt;</span><span class=n>heap_allocated</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>result</span><span class=o>-&gt;</span><span class=n>cachable</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>  <span class=c1>// Do not double-cache
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>result</span><span class=o>-&gt;</span><span class=n>data</span> <span class=o>=</span> <span class=n>Slice</span><span class=p>(</span><span class=n>buf</span><span class=p>,</span> <span class=n>n</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>result</span><span class=o>-&gt;</span><span class=n>heap_allocated</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>result</span><span class=o>-&gt;</span><span class=n>cachable</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=c1>// Ok
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=nl>kSnappyCompression</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>size_t</span> <span class=n>ulength</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=c1>// 获取 snappy 压缩前的数据的大小以分配内存
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>port</span><span class=o>::</span><span class=n>Snappy_GetUncompressedLength</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=n>n</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>ulength</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>delete</span><span class=p>[]</span> <span class=n>buf</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>Status</span><span class=o>::</span><span class=n>Corruption</span><span class=p>(</span><span class=s>&#34;corrupted compressed block contents&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=kt>char</span><span class=o>*</span> <span class=n>ubuf</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>char</span><span class=p>[</span><span class=n>ulength</span><span class=p>];</span>
</span></span><span class=line><span class=cl>      <span class=c1>// 将 snappy 压缩过的数据解压缩到上面分配的内存中
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>port</span><span class=o>::</span><span class=n>Snappy_Uncompress</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=n>n</span><span class=p>,</span> <span class=n>ubuf</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>delete</span><span class=p>[]</span> <span class=n>buf</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>delete</span><span class=p>[]</span> <span class=n>ubuf</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>Status</span><span class=o>::</span><span class=n>Corruption</span><span class=p>(</span><span class=s>&#34;corrupted compressed block contents&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=k>delete</span><span class=p>[]</span> <span class=n>buf</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=n>result</span><span class=o>-&gt;</span><span class=n>data</span> <span class=o>=</span> <span class=n>Slice</span><span class=p>(</span><span class=n>ubuf</span><span class=p>,</span> <span class=n>ulength</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=n>result</span><span class=o>-&gt;</span><span class=n>heap_allocated</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=n>result</span><span class=o>-&gt;</span><span class=n>cachable</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>default</span><span class=o>:</span>
</span></span><span class=line><span class=cl>      <span class=k>delete</span><span class=p>[]</span> <span class=n>buf</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=n>Status</span><span class=o>::</span><span class=n>Corruption</span><span class=p>(</span><span class=s>&#34;bad block type&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>Status</span><span class=o>::</span><span class=n>OK</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=23-table-和两级迭代器的结合 class=headerLink><a href=#23-table-%e5%92%8c%e4%b8%a4%e7%ba%a7%e8%bf%ad%e4%bb%a3%e5%99%a8%e7%9a%84%e7%bb%93%e5%90%88 class=header-mark></a>2.3 Table 和两级迭代器的结合</h3><p>前面讲过了, 打开 sstable 文件后会生成对应的 Table 对象, 该对象会被放到 TableCache 缓存中. 如果要访问其内容, 需要一个迭代器, 该工作通过 <code>leveldb::Iterator *leveldb::Table::NewIterator</code> 完成:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// 先为 data-index block 数据项构造一个迭代器 index_iter, 
</span></span></span><span class=line><span class=cl><span class=c1>// 然后基于 index_iter 查询时, 为其指向的具体 data block 
</span></span></span><span class=line><span class=cl><span class=c1>// 构造一个迭代器 data_iter, 进而可以迭代该 data block 里
</span></span></span><span class=line><span class=cl><span class=c1>// 的全部数据项.
</span></span></span><span class=line><span class=cl><span class=c1>// 这样就构成了一个两级迭代器, 从而实现遍历全部 data blocks 的数据项. 
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Iterator</span><span class=o>*</span> <span class=n>Table</span><span class=o>::</span><span class=n>NewIterator</span><span class=p>(</span><span class=k>const</span> <span class=n>ReadOptions</span><span class=o>&amp;</span> <span class=n>options</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nf>NewTwoLevelIterator</span><span class=p>(</span>
</span></span><span class=line><span class=cl>      <span class=n>rep_</span><span class=o>-&gt;</span><span class=n>index_block</span><span class=o>-&gt;</span><span class=n>NewIterator</span><span class=p>(</span><span class=n>rep_</span><span class=o>-&gt;</span><span class=n>options</span><span class=p>.</span><span class=n>comparator</span><span class=p>),</span>
</span></span><span class=line><span class=cl>      <span class=o>&amp;</span><span class=n>Table</span><span class=o>::</span><span class=n>BlockReader</span><span class=p>,</span> <span class=k>const_cast</span><span class=o>&lt;</span><span class=n>Table</span><span class=o>*&gt;</span><span class=p>(</span><span class=k>this</span><span class=p>),</span> <span class=n>options</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>返回的迭代器为一个 <code>leveldb::&lt;unnamed>::TwoLevelIterator</code>, 该迭代器处于匿名的命名空间所以未直接对外暴露, 仅能通过返回的指针访问其从 <code>class leveldb::Iterator</code> 继承的方法.</p><p>每个 sstable 文件对应一个两级迭代器, 然后将全部 sstable 对应的两级迭代器级联起来, 就相当于为整个 leveldb 构造了一个迭代器(见 <code>leveldb::Version::AddIterators()</code>, 后续会详解该类), 从而实现在整个 leveldb 上轻松实现迭代或者查询.</p><p>&ndash;End&ndash;</p></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>更新于 2021-05-29</span></div><div class=post-info-license></div></div><div class=post-info-line><div class=post-info-md><span><a class=link-to-mardown href=/leveldb-annotations-5-sstable/index.md target=_blank rel="noopener noreferrer">阅读原始文档</a></span></div><div class=post-info-share><span><a href=# title="分享到 Twitter" data-sharer=twitter data-url=https://chienlungcheung.github.io/leveldb-annotations-5-sstable/ data-title="Leveldb 源码详解系列之五: SSTable 设计与实现" data-via=haricheung data-hashtags=leveldb,LSM-Tree,db,kv><i class="fab fa-twitter fa-fw"></i></a><a href=# title="分享到 Facebook" data-sharer=facebook data-url=https://chienlungcheung.github.io/leveldb-annotations-5-sstable/ data-hashtag=leveldb><i class="fab fa-facebook-square fa-fw"></i></a><a href=# title="分享到 WhatsApp" data-sharer=whatsapp data-url=https://chienlungcheung.github.io/leveldb-annotations-5-sstable/ data-title="Leveldb 源码详解系列之五: SSTable 设计与实现" data-web><i class="fab fa-whatsapp fa-fw"></i></a><a href=# title="分享到 Line" data-sharer=line data-url=https://chienlungcheung.github.io/leveldb-annotations-5-sstable/ data-title="Leveldb 源码详解系列之五: SSTable 设计与实现"><i data-svg-src=/lib/simple-icons/icons/line.min.svg></i></a><a href=# title="分享到 微博" data-sharer=weibo data-url=https://chienlungcheung.github.io/leveldb-annotations-5-sstable/ data-title="Leveldb 源码详解系列之五: SSTable 设计与实现"><i class="fab fa-weibo fa-fw"></i></a><a href=# title="分享到 Myspace" data-sharer=myspace data-url=https://chienlungcheung.github.io/leveldb-annotations-5-sstable/ data-title="Leveldb 源码详解系列之五: SSTable 设计与实现" data-description><i data-svg-src=/lib/simple-icons/icons/myspace.min.svg></i></a><a href=# title="分享到 Blogger" data-sharer=blogger data-url=https://chienlungcheung.github.io/leveldb-annotations-5-sstable/ data-title="Leveldb 源码详解系列之五: SSTable 设计与实现" data-description><i class="fab fa-blogger fa-fw"></i></a><a href=# title="分享到 Evernote" data-sharer=evernote data-url=https://chienlungcheung.github.io/leveldb-annotations-5-sstable/ data-title="Leveldb 源码详解系列之五: SSTable 设计与实现"><i class="fab fa-evernote fa-fw"></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/leveldb/>leveldb</a>,&nbsp;<a href=/tags/lsm-tree/>LSM-Tree</a>,&nbsp;<a href=/tags/db/>db</a>,&nbsp;<a href=/tags/kv/>kv</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/mapreduce-design-and-implementation/ class=prev rel=prev title="MapReduce: 分布式计算系统设计与实现"><i class="fas fa-angle-left fa-fw"></i>MapReduce: 分布式计算系统设计与实现</a>
<a href=/leveldb-annotations-6-table-cache/ class=next rel=next title="Leveldb 源码详解系列之六: 文件缓存设计与实现">Leveldb 源码详解系列之六: 文件缓存设计与实现<i class="fas fa-angle-right fa-fw"></i></a></div></div><div id=comments><div id=disqus_thread class=comment></div><noscript>Please enable JavaScript to view the comments powered by <a href=https://disqus.com/?ref_noscript>Disqus</a>.</noscript></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line>由 <a href=https://gohugo.io/ target=_blank rel="noopener noreferrer" title="Hugo 0.120.1">Hugo</a> 强力驱动&nbsp;|&nbsp;主题 - <a href=https://github.com/HEIGE-PCloud/DoIt target=_blank rel="noopener noreferrer" title="DoIt 0.3.0"><i class="far fa-edit fa-fw"></i> DoIt</a></div><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2019 - 2023</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=/ target=_blank rel="noopener noreferrer">Hari</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div><div class=footer-line></div><div class=footer-line></div></div></footer></div><div id=fixed-buttons><a href=#back-to-top id=back-to-top-button class=fixed-button title=回到顶部><i class="fas fa-arrow-up fa-fw"></i>
</a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment fa-fw"></i></a></div><div class=assets><link rel=stylesheet href=/lib/katex/katex.min.css><link rel=preload as=style onload='this.onload=null,this.rel="stylesheet"' href=/lib/katex/copy-tex.min.css><noscript><link rel=stylesheet href=/lib/katex/copy-tex.min.css></noscript><script type=text/javascript>window.config={code:{copyTitle:"复制到剪贴板",maxShownLines:10},comment:{},math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},search:{distance:100,findAllMatches:!1,fuseIndexURL:"/index.json",highlightTag:"em",ignoreFieldNorm:!1,ignoreLocation:!1,isCaseSensitive:!1,location:0,maxResultLength:10,minMatchCharLength:2,noResultsFound:"没有找到结果",snippetLength:50,threshold:.3,type:"fuse",useExtendedSearch:!1},sharerjs:!0,table:{sort:!0}}</script><script type=text/javascript src=https://Chienlung.disqus.com/embed.js defer></script><script type=text/javascript src=/lib/tablesort/tablesort.min.js></script><script type=text/javascript src=/lib/clipboard/clipboard.min.js></script><script type=text/javascript src=/lib/sharer/sharer.min.js></script><script type=text/javascript src=/lib/katex/katex.min.js defer></script><script type=text/javascript src=/lib/katex/auto-render.min.js defer></script><script type=text/javascript src=/lib/katex/copy-tex.min.js defer></script><script type=text/javascript src=/lib/katex/mhchem.min.js defer></script><script type=text/javascript src=/js/katex.min.js defer></script><script type=text/javascript src=/js/theme.min.js defer></script></div></body></html>